<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="date" content="2023-04-03" />

<meta name="progressive" content="true" />
<meta name="allow-skip" content="false" />
<meta name="learnr-version-prerender" content="0.10.6.9000" />

<title>2.3 Cost Curves</title>

<!-- header-includes START -->
<!-- HEAD_CONTENT -->
<!-- header-includes END -->
<!-- HEAD_CONTENT -->

<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>


<!-- taken from https://github.com/rstudio/rmarkdown/blob/de8a9c38618903627ca509f5401d50a0876079f7/inst/rmd/h/default.html#L293-L343 -->
<!-- tabsets -->
<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->


</head>

<body>
<a class='sr-only sr-only-focusable visually-hidden-focusable' href='#learnr-tutorial-content'>Skip to Tutorial Content</a>



<div class="pageContent band">
<main class="bandContent page">

<article class="topics" id="learnr-tutorial-content">

<style type="text/css">
h1{font-size: 24pt}
h2{font-size: 20pt}
h3{font-size: 18pt}
h4,h5,h6{font-size: 16pt}
body{font-size: 16pt}
#doc-metadata {
  margin-bottom: 10px;
  font-size: 0.66em;
}
</style>
<div id="section-review-the-firms-three-problems"
class="section level2">
<h2>Review: The Firm’s Three Problems:</h2>
<ol style="list-style-type: decimal">
<li><span style="color: red;">Cost-Minimizing Combination of Inputs: For
a <em>given</em> level of (expected) output (firm demand) choose the
<em>combination</em> of inputs that minimizes the cost of producing that
amount to derive the cost function.</span></li>
<li>Profit-Maximizing Level of Output: Choose the <em>level</em> of
output that maximizes profits by adjusting quantity and/or price of the
output.</li>
<li>Long-Run Readjustment: Adjust the level of capital to minimize costs
at the given price and quantity in the market. This might happen at the
firm level (adjusting firm capacity) or at the industry level
(entry/exit of firms).</li>
</ol>
<div id="section-long-run-cost-curves" class="section level3">
<h3>Long-Run Cost Curves</h3>
<p>A rational firm starts out by taking a long-run view of their market.
To do this, it will determine the different levels and combinations of
inputs that minimize its long run costs.</p>
<p>Then, it must budget its fixed inputs (in our example, capital) based
on (1) the quantity it expects to sell; and (2) the least-costly way to
produce that quantity with its production methods.</p>
</div>
<div id="section-initial-solution" class="section level3">
<h3>Initial Solution</h3>
<p>For expected sales of <span class="math inline">\(y = 2500\)</span>
units of output and inpput prices <span class="math inline">\(w =
10\)</span> and <span class="math inline">\(w = 20\)</span>, the firm in
our previous example minimized costs at 25 units of labor and 25 units
of capital at a total cost of 75.</p>
<p>To find costs over several quantities (i.e. a cost
<em>schedule</em>), all we need to do is solve the cost-minimization
problem for many different levels of output. Computationally, we can do
this using a <em>for-loop</em>.</p>
<p>Run the following code to iterate the cost-minimization problem over
any values of output to find the optimal levels of labor, capital, and
cost for levels of output from 0 to 5,000 in increments of 100.</p>
<details style="line-height:105%">
<summary>
Click here to view the steps for writing the loop.
</summary>
<ol style="list-style-type: decimal">
<li>Initialize a new <code>data.frame</code> object named
<code>costSchedule</code> with variables <code>Quantity</code>,
<code>Labor</code>, <code>Capital</code>, <code>Total_Cost</code>, and
<code>Average_Cost</code>. <br> Set the values of <code>Quantity</code>
equal to the sequence of outputs from 0 to 5,000 by increments of 100,
and the other variables equal to <code>NA</code>.</li>
<li>Begin a <code>for(...) {...}</code> loop starting at
<code>i = 1</code> through the number of rows (<code>nrow()</code>) in
costSchedule that does the following for each <code>i</code>:</li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Compute the solution to the cost-minimization problem for the
quantity of output in row <code>i</code> of
<code>costSchedule$Quantity</code> and (temporarily) stores the result
as <code>costMinTemp</code>.</li>
<li>Assigns the <span class="math inline">\(i^th\)</span> row of the
<code>Labor</code> variable in <code>costSchedule</code> equal to the
first value in the <code>solution</code> variable in the
<code>costMinTemp</code> object, and assigns the <span
class="math inline">\(i^th\)</span> row of <code>Capital</code> equal to
the second value of <code>solution</code>.</li>
<li>Assigns the last value (<code>tail(x, 1)</code>) of the
<code>values</code> in <code>costMinTemp</code> to the
<code>Total_Cost</code> variable, and calculates the average cost as
<code>Total_Cost</code> divided by <code>Quantity</code>.</li>
</ol>
</details>
<div class="tutorial-exercise" data-label="costSchedule"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>crtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q&#39;s 
    Labor = NA,
    Capital = NA,
    Total_Cost = NA,
    Average_Cost = NA
  )
tc &lt;- function(x) {
  w * x[1] + r * x[2]                                       # Define objective 
}
crts &lt;- function(x) {
  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint
}
for (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop
  costMinTemp &lt;- solnp(
    pars = c(1, 1),                                         # Set initial pars
    fun = tc,
    ineqfun = crts,
    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]
    ineqUB = Inf,
    LB = c(0, 0),                                           # Nonnegative constraint
    UB = c(Inf, Inf), 
    control = list(trace = 0)
  )
  crtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]              # Optimal labor input
  crtsSchedule$Capital[i] &lt;- costMinTemp$pars[2]            # Optimal capital input
  crtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1) # Calculate total cost
}
crtsSchedule$Average_Cost &lt;-
  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC
head(crtsSchedule)                                          # Print the 1st 6 rows</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support"
data-label="costSchedule-solution" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>crtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q&#39;s 
    Labor = NA,
    Capital = NA,
    Total_Cost = NA,
    Average_Cost = NA
  )
tc &lt;- function(x) {
  w * x[1] + r * x[2]                                       # Define objective 
}
crts &lt;- function(x) {
  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint
}
for (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop
  costMinTemp &lt;- solnp(
    pars = c(1, 1),                                         # Set initial pars
    fun = tc,
    ineqfun = crts,
    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]
    ineqUB = Inf,
    LB = c(0, 0),                                           # Nonnegative constraint
    UB = c(Inf, Inf), 
    control = list(trace = 0)
  )
  crtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]              # Optimal labor input
  crtsSchedule$Capital[i] &lt;- costMinTemp$pars[2]            # Optimal capital input
  crtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1) # Calculate total cost
}
crtsSchedule$Average_Cost &lt;-
  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC
head(crtsSchedule)                                          # Print the 1st 6 rows</code></pre>
</div>
</div>
</div>
<div id="section-graphical-analysis" class="section level2">
<h2>Graphical Analysis</h2>
<div id="section-constant-returns-to-scale" class="section level3">
<h3>Constant Returns to Scale</h3>
<p>Plot total costs as functions of quantity.</p>
<div class="tutorial-exercise" data-label="tcGraph" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="8">
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="tcGraph-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>plot(
  crtsSchedule$Quantity,
  crtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 1500),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)</code></pre>
</div>
<p>Plot average costs as functions of quantity.</p>
<div class="tutorial-exercise" data-label="atcGraph" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="atcGraph-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>plot(
  crtsSchedule$Quantity,
  crtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Long-Run Average Cost&quot;
)</code></pre>
</div>
</div>
<div id="section-side-by-side-plots" class="section level3">
<h3>Side-by-Side Plots</h3>
<p>You can display the plots on the same plot area using
<code>par(mfrow = c(nrow, ncol))</code>. I demonstrate this below:</p>
<pre><code>## Warning: package &#39;Rsolnp&#39; was built under R version 4.2.2</code></pre>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(
  crtsSchedule$Quantity,
  crtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 1500),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  crtsSchedule$Quantity,
  crtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)</code></pre>
<p><img src="2_3_files/figure-html/costsSideBySide-1.png" width="768" /></p>
</div>
<div id="section-graphical-example-with-diminishing-returns"
class="section level3">
<h3>Graphical Example with Diminishing Returns</h3>
<p>A quick way to get an increasing cost function is to redefine the
production function so that the sum of the Cobb-Douglas exponents is
less than one. This creates <em>decreasing</em> (instead of constant)
returns to scale, and therefore <em>increasing</em> average costs. For
example, <span class="math display">\[Q = f(L, K) = 100 L^{1/3}
K^{1/3}\]</span></p>
<p>Run the following code to illustrate increasing costs.</p>
<div class="tutorial-exercise" data-label="drtsGraph"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>drtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q&#39;s 
    Labor = NA,
    Capital = NA,
    Total_Cost = NA,
    Average_Cost = NA
  )
drts &lt;- function(x) {
  100 * x[1] ^ alpha * x[2] ^ alpha                         # Define constraint
}
# Since alpha = 1/3, the exponents sum to less than one. 
for (i in 1:nrow(drtsSchedule)) {                           # Initialize for-loop
  costMinTemp &lt;- solnp(
    pars = c(1, 1),                                         # Set initial pars
    fun = tc,
    ineqfun = drts,
    ineqLB = drtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]
    ineqUB = Inf,
    LB = c(0, 0),                                           # Nonnegative constraint
    UB = c(Inf, Inf), 
    control = list(trace = 0)
  )
  drtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]              # Optimal labor input
  drtsSchedule$Capital[i] &lt;- costMinTemp$pars[2]            # Optimal capital input
  drtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1) # Calculate total cost
}
drtsSchedule$Average_Cost &lt;-
  drtsSchedule$Total_Cost / drtsSchedule$Quantity           # Calculate ATC
par(mfrow = c(1, 2))
plot(
  drtsSchedule$Quantity,
  drtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 10000),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  drtsSchedule$Quantity,
  drtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 2),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)
head(drtsSchedule)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="drtsGraph-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>drtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q&#39;s 
    Labor = NA,
    Capital = NA,
    Total_Cost = NA,
    Average_Cost = NA
  )
drts &lt;- function(x) {
  100 * x[1] ^ alpha * x[2] ^ alpha                         # Define constraint
}
# Since alpha = 1/3, the exponents sum to less than one. 
for (i in 1:nrow(drtsSchedule)) {                           # Initialize for-loop
  costMinTemp &lt;- solnp(
    pars = c(1, 1),                                         # Set initial pars
    fun = tc,
    ineqfun = drts,
    ineqLB = drtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]
    ineqUB = Inf,
    LB = c(0, 0),                                           # Nonnegative constraint
    UB = c(Inf, Inf), 
    control = list(trace = 0)
  )
  drtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]              # Optimal labor input
  drtsSchedule$Capital[i] &lt;- costMinTemp$pars[2]            # Optimal capital input
  drtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1) # Calculate total cost
}
drtsSchedule$Average_Cost &lt;-
  drtsSchedule$Total_Cost / drtsSchedule$Quantity           # Calculate ATC
par(mfrow = c(1, 2))
plot(
  drtsSchedule$Quantity,
  drtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 10000),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  drtsSchedule$Quantity,
  drtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 2),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)
head(drtsSchedule)</code></pre>
</div>
</div>
<div id="section-graphical-example-with-increasing-returns"
class="section level3">
<h3>Graphical Example with Increasing Returns</h3>
<p>Similarly, we can force a decreasing cost function by redefining the
exponents in our Cobb-Douglas function so that their sum is greater than
one. Such a technology exhibits <em>increasing</em> returns to scale and
therefore <em>decreasing</em> average costs. For example, <span
class="math display">\[Q = f(L, K) = 100 L^{2/3} K^{2/3}\]</span></p>
<p>Run the following code to simulate decreasing costs.</p>
<div class="tutorial-exercise" data-label="irtsGraph"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>irtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q&#39;s 
    Labor = NA,
    Capital = NA,
    Total_Cost = NA,
    Average_Cost = NA
  )
irts &lt;- function(x) {
  100 * x[1] ^ (2*alpha) * x[2] ^ (2*alpha)                 # Define constraint
}
# Since alpha = 1/3, the exponents sum to more than one. 
for (i in 1:nrow(irtsSchedule)) {                           # Initialize for-loop
  costMinTemp &lt;- solnp(
    pars = c(1, 1),                                         # Set initial pars
    fun = tc,
    ineqfun = irts,
    ineqLB = irtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]
    ineqUB = Inf,
    LB = c(0, 0),                                           # Nonnegative constraint
    UB = c(Inf, Inf), 
    control = list(trace = 0)
  )
  irtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]              # Optimal labor input
  irtsSchedule$Capital[i] &lt;- costMinTemp$pars[2]            # Optimal capital input
  irtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1) # Calculate total cost
}
irtsSchedule$Average_Cost &lt;-
  irtsSchedule$Total_Cost / irtsSchedule$Quantity           # Calculate ATC
par(mfrow = c(1, 2))
plot(
  irtsSchedule$Quantity,
  irtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 600),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  irtsSchedule$Quantity,
  irtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)
head(irtsSchedule)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="irtsGraph-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>irtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q&#39;s 
    Labor = NA,
    Capital = NA,
    Total_Cost = NA,
    Average_Cost = NA
  )
irts &lt;- function(x) {
  100 * x[1] ^ (2*alpha) * x[2] ^ (2*alpha)                 # Define constraint
}
# Since alpha = 1/3, the exponents sum to more than one. 
for (i in 1:nrow(irtsSchedule)) {                           # Initialize for-loop
  costMinTemp &lt;- solnp(
    pars = c(1, 1),                                         # Set initial pars
    fun = tc,
    ineqfun = irts,
    ineqLB = irtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]
    ineqUB = Inf,
    LB = c(0, 0),                                           # Nonnegativity constraint
    UB = c(Inf, Inf), 
    control = list(trace = 0)
  )
  irtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]              # Optimal labor input
  irtsSchedule$Capital[i] &lt;- costMinTemp$pars[2]            # Optimal capital input
  irtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1) # Calculate total cost
}
irtsSchedule$Average_Cost &lt;-
  irtsSchedule$Total_Cost / irtsSchedule$Quantity           # Calculate ATC
par(mfrow = c(1, 2))
plot(
  irtsSchedule$Quantity,
  irtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 600),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  irtsSchedule$Quantity,
  irtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)
head(irtsSchedule)</code></pre>
</div>
<p>At the end of the day the nature of costs as the firm scales up its
inputs is an empirical question. Businesses seeking to optimize input
and output decisions hire professional economists to estimate both sales
and costs.</p>
</div>
</div>
<div id="section-short-run-cost-curves" class="section level2">
<h2>Short-Run Cost Curves</h2>
<p>In our example, the firm initially anticipated sales of 2500 units.
Based on this expectation it budgeted for 25 “units” of capital. Next,
the firm just choose inputs (and outputs) based on its short-run
costs.</p>
<div id="section-total-cost-and-average-cost" class="section level3">
<h3>Total Cost and Average Cost</h3>
<p>With a fixed input (in the short run), a constant returns <em>to
scale</em> technology becomes a diminishing returns <em>to the variable
input(s)</em> technology. This introduces increasing costs, as
demonstrated by the increasing slope of total cost.</p>
<p>Run the following code to simulate and graph the short run total and
average cost curves for our example.</p>
<div class="tutorial-exercise" data-label="srTotalCost"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>srCrtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),
    Labor = NA,
    Capital = 25,
    Total_Cost = NA,
    Average_Cost = NA
  )
srCrts &lt;- function(x) {
  100 * x ^ (alpha) * 25 ^ (1 - alpha)
}
srtc &lt;- function(x) {
  w * x + r * 25
}
for (i in 1:nrow(srCrtsSchedule)) {
  costMinTemp &lt;- solnp(
    pars = 1,
    fun = srtc,
    ineqfun = srCrts,
    ineqLB = srCrtsSchedule$Quantity[i],
    ineqUB = Inf,
    LB = 0,
    UB = Inf,
    control = list(trace = 0)
  )
  srCrtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]
  srCrtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1)
}
srCrtsSchedule$Average_Cost &lt;-
  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity
par(mfrow = c(1, 2))
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 2500),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Total Cost&quot;
)
head(srCrtsSchedule)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="srTotalCost-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>srCrtsSchedule &lt;-
  data.frame(
    Quantity = seq(from = 0, to = 5000, by = 100),
    Labor = NA,
    Capital = 25,
    Total_Cost = NA,
    Average_Cost = NA
  )
srCrts &lt;- function(x) {
  100 * x ^ (alpha) * 25 ^ (1 - alpha)
}
srtc &lt;- function(x) {
  w * x + r * 25
}
for (i in 1:nrow(srCrtsSchedule)) {
  costMinTemp &lt;- solnp(
    pars = 1,
    fun = srtc,
    ineqfun = srCrts,
    ineqLB = srCrtsSchedule$Quantity[i],
    ineqUB = Inf,
    LB = 0,
    UB = Inf,
    control = list(trace = 0)
  )
  srCrtsSchedule$Labor[i] &lt;- costMinTemp$pars[1]
  srCrtsSchedule$Total_Cost[i] &lt;- tail(costMinTemp$values, 1)
}
srCrtsSchedule$Average_Cost &lt;-
  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity
par(mfrow = c(1, 2))
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 2500),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Total Cost&quot;
)
head(srCrtsSchedule)</code></pre>
</div>
</div>
<div id="section-variable-costs" class="section level3">
<h3>Variable Costs</h3>
<p>Variable costs are costs associated with variable inputs (in our
example labor). They are costs (and input decisions) that the firm can
directly control in the short run.</p>
<p>Run the following code to simulate and graph total and average
variable costs for our example.</p>
<div class="tutorial-exercise" data-label="variableCost"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>srCrtsSchedule$Variable_Cost &lt;- w * srCrtsSchedule$Labor
srCrtsSchedule$Average_Variable_Cost &lt;-
    srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 2500),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
lines(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Variable_Cost,
  col = &#39;purple&#39;
)
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)
lines(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Variable_Cost,
  col = &#39;purple&#39;
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support"
data-label="variableCost-solution" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>srCrtsSchedule$Variable_Cost &lt;- w * srCrtsSchedule$Labor
srCrtsSchedule$Average_Variable_Cost &lt;-
  srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Total_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 2500),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Total Cost&quot;
)
lines(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Variable_Cost,
  type = &#39;l&#39;,
  col = &#39;purple&#39;
)
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average Cost&quot;
)
lines(srCrtsSchedule$Quantity,
      srCrtsSchedule$Average_Variable_Cost,
      col = &#39;purple&#39;)</code></pre>
</div>
</div>
<div id="section-marginal-costs" class="section level3">
<h3>Marginal Costs</h3>
<p>Marginal cost measures the rate at which total (or total vairable)
cost changes as the firm increases its output by very small amounts. In
our numerical simulation, we really only approximate the instantaneous
value of the change because our code requires discrete changes (and
because we’re not deriving the full cost function symbolically).</p>
<p>To partially compensate for this, we will average the change between
the current cost and the <em>previous</em> cost with the change between
the current cost and the <em>next</em> cost.</p>
<p>By definition, the <em>derivative</em> of the cost function takes a
similar approach, but takes the limit as <span
class="math inline">\(\Delta Q \to 0\)</span>.</p>
<p>Run the following code to add marginal cost to the cost schedule and
to the graphs.</p>
<div class="tutorial-exercise" data-label="marginalCost"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>par(mfrow = c(1, 1))
# Find TC(Q_{i+1}) - TC(Q_{i-1}) / (2 * dQ)
srCrtsSchedule$Marginal_Cost &lt;- 
  c(NA,diff(srCrtsSchedule$Total_Cost, lag = 2)/200, NA)
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average/Marginal Cost&quot;
)
lines(srCrtsSchedule$Quantity,
      srCrtsSchedule$Average_Variable_Cost,
      col = &#39;purple&#39;)
lines(srCrtsSchedule$Quantity,
      srCrtsSchedule$Marginal_Cost,
      col = &#39;red&#39;)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support"
data-label="marginalCost-solution" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>srCrtsSchedule$Marginal_Cost &lt;- 
  c(NA,diff(srCrtsSchedule$Total_Cost, lag = 2)/200, NA)
plot(
  srCrtsSchedule$Quantity,
  srCrtsSchedule$Average_Cost,
  type = &#39;l&#39;,
  ylim = c(0, 0.5),
  xlab = &quot;Quantity&quot;,
  ylab = &quot;Average/Marginal Cost&quot;
)
lines(srCrtsSchedule$Quantity,
      srCrtsSchedule$Average_Variable_Cost,
      col = &#39;purple&#39;)
lines(srCrtsSchedule$Quantity,
      srCrtsSchedule$Marginal_Cost,
      col = &#39;red&#39;)</code></pre>
</div>
<p>
<script type="application/shiny-prerendered" data-context="server-start">
library(learnr)
library(gradethis)
gradethis_setup(exercise.reveal_solution = TRUE)
knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>


<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-costSchedule-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-costSchedule-code-editor`)), session)
output$`tutorial-exercise-costSchedule-output` <- renderUI({
  `tutorial-exercise-costSchedule-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "costSchedule", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ny0 = 2500\ncostMin <- solnp(\n  pars = c(1, 1),\n  fun = function(x)\n    w * x[1] + r * x[2],\n  ineqfun = function(x)\n    100 * x[1] ^ alpha * x[2] ^ (1 - alpha),\n  ineqLB = y0,\n  ineqUB = Inf,\n  LB = c(0, 0),\n  control = list(trace = 0)\n)", 
    chunks = list(list(label = "initialSolution", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ny0 = 2500\ncostMin <- solnp(\n  pars = c(1, 1),\n  fun = function(x)\n    w * x[1] + r * x[2],\n  ineqfun = function(x)\n    100 * x[1] ^ alpha * x[2] ^ (1 - alpha),\n  ineqLB = y0,\n  ineqUB = Inf,\n  LB = c(0, 0),\n  control = list(trace = 0)\n)", 
        opts = list(label = "\"initialSolution\"", echo = "TRUE"), 
        engine = "r"), list(label = "costSchedule", code = "crtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC\nhead(crtsSchedule)                                          # Print the 1st 6 rows", 
        opts = list(label = "\"costSchedule\"", exercise = "TRUE", 
            exercise.setup = "\"initialSolution\""), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "costSchedule-check")), solution = structure(c("crtsSchedule <-", 
    "  data.frame(", "    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's ", 
    "    Labor = NA,", "    Capital = NA,", "    Total_Cost = NA,", 
    "    Average_Cost = NA", "  )", "tc <- function(x) {", "  w * x[1] + r * x[2]                                       # Define objective ", 
    "}", "crts <- function(x) {", "  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint", 
    "}", "for (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop", 
    "  costMinTemp <- solnp(", "    pars = c(1, 1),                                         # Set initial pars", 
    "    fun = tc,", "    ineqfun = crts,", "    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]", 
    "    ineqUB = Inf,", "    LB = c(0, 0),                                           # Nonnegative constraint", 
    "    UB = c(Inf, Inf), ", "    control = list(trace = 0)", 
    "  )", "  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input", 
    "  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input", 
    "  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost", 
    "}", "crtsSchedule$Average_Cost <-", "  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
    "head(crtsSchedule)                                          # Print the 1st 6 rows"
    ), chunk_opts = list(label = "costSchedule-solution")), tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "2_3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "2_3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6, fig.height = 6, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 576, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, exercise.timelimit = 60, 
        exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "costSchedule", 
        exercise = TRUE, exercise.setup = "initialSolution", 
        code = c("crtsSchedule <-", "  data.frame(", "    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's ", 
        "    Labor = NA,", "    Capital = NA,", "    Total_Cost = NA,", 
        "    Average_Cost = NA", "  )", "tc <- function(x) {", 
        "  w * x[1] + r * x[2]                                       # Define objective ", 
        "}", "crts <- function(x) {", "  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint", 
        "}", "for (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop", 
        "  costMinTemp <- solnp(", "    pars = c(1, 1),                                         # Set initial pars", 
        "    fun = tc,", "    ineqfun = crts,", "    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]", 
        "    ineqUB = Inf,", "    LB = c(0, 0),                                           # Nonnegative constraint", 
        "    UB = c(Inf, Inf), ", "    control = list(trace = 0)", 
        "  )", "  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input", 
        "  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input", 
        "  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost", 
        "}", "crtsSchedule$Average_Cost <-", "  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
        "head(crtsSchedule)                                          # Print the 1st 6 rows"
        ), out.width.px = 576, out.height.px = 576, params.src = "costSchedule, exercise = TRUE, exercise.setup = 'initialSolution'", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-tcGraph-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-tcGraph-code-editor`)), session)
output$`tutorial-exercise-tcGraph-output` <- renderUI({
  `tutorial-exercise-tcGraph-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "tcGraph", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
    chunks = list(list(label = "tcGraph-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
        opts = list(label = "\"tcGraph-setup\""), engine = "r"), 
        list(label = "tcGraph", code = "", opts = list(label = "\"tcGraph\"", 
            exercise = "TRUE", exercise.lines = "8"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "tcGraph-check")), solution = structure(c("plot(", 
    "  crtsSchedule$Quantity,", "  crtsSchedule$Total_Cost,", 
    "  type = 'l',", "  ylim = c(0, 1500),", "  xlab = \"Quantity\",", 
    "  ylab = \"Total Cost\"", ")"), chunk_opts = list(label = "tcGraph-solution")), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "2_3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "2_3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6, fig.height = 6, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 576, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, exercise.timelimit = 60, 
        exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "tcGraph", exercise = TRUE, 
        exercise.lines = 8, code = "", out.width.px = 576, out.height.px = 576, 
        params.src = "tcGraph, exercise = TRUE, exercise.lines = 8", 
        fig.num = 0L, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-atcGraph-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-atcGraph-code-editor`)), session)
output$`tutorial-exercise-atcGraph-output` <- renderUI({
  `tutorial-exercise-atcGraph-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "atcGraph", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
    chunks = list(list(label = "atcGraph-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
        opts = list(label = "\"atcGraph-setup\""), engine = "r"), 
        list(label = "atcGraph", code = "", opts = list(label = "\"atcGraph\"", 
            exercise = "TRUE"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure(c("grade_code(\"Notice that we confirm that the Cobb-Douglas production function has", 
    "           constant returns to scale.\")"), chunk_opts = list(
        label = "atcGraph-check")), solution = structure(c("plot(", 
    "  crtsSchedule$Quantity,", "  crtsSchedule$Average_Cost,", 
    "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
    "  ylab = \"Long-Run Average Cost\"", ")"), chunk_opts = list(
        label = "atcGraph-solution")), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "2_3_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "2_3_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6, fig.height = 6, fig.env = "figure", fig.cap = NULL, 
        fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 576, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "atcGraph", 
        exercise = TRUE, code = "", out.width.px = 576, out.height.px = 576, 
        params.src = "atcGraph, exercise = TRUE", fig.num = 0L, 
        exercise.df_print = "paged"), engine = "r", version = "4"), class = c("r", 
"tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-drtsGraph-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-drtsGraph-code-editor`)), session)
output$`tutorial-exercise-drtsGraph-output` <- renderUI({
  `tutorial-exercise-drtsGraph-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "drtsGraph", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
    chunks = list(list(label = "drtsGraph-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
        opts = list(label = "\"drtsGraph-setup\""), engine = "r"), 
        list(label = "drtsGraph", code = "drtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ndrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ alpha                         # Define constraint\n}\n# Since alpha = 1/3, the exponents sum to less than one. \nfor (i in 1:nrow(drtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = drts,\n    ineqLB = drtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  drtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  drtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  drtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ndrtsSchedule$Average_Cost <-\n  drtsSchedule$Total_Cost / drtsSchedule$Quantity           # Calculate ATC\npar(mfrow = c(1, 2))\nplot(\n  drtsSchedule$Quantity,\n  drtsSchedule$Total_Cost,\n  type = 'l',\n  ylim = c(0, 10000),\n  xlab = \"Quantity\",\n  ylab = \"Total Cost\"\n)\nplot(\n  drtsSchedule$Quantity,\n  drtsSchedule$Average_Cost,\n  type = 'l',\n  ylim = c(0, 2),\n  xlab = \"Quantity\",\n  ylab = \"Average Cost\"\n)\nhead(drtsSchedule)", 
            opts = list(label = "\"drtsGraph\"", exercise = "TRUE"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = structure(c("drtsSchedule <-", "  data.frame(", 
    "    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's ", 
    "    Labor = NA,", "    Capital = NA,", "    Total_Cost = NA,", 
    "    Average_Cost = NA", "  )", "drts <- function(x) {", 
    "  100 * x[1] ^ alpha * x[2] ^ alpha                         # Define constraint", 
    "}", "# Since alpha = 1/3, the exponents sum to less than one. ", 
    "for (i in 1:nrow(drtsSchedule)) {                           # Initialize for-loop", 
    "  costMinTemp <- solnp(", "    pars = c(1, 1),                                         # Set initial pars", 
    "    fun = tc,", "    ineqfun = drts,", "    ineqLB = drtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]", 
    "    ineqUB = Inf,", "    LB = c(0, 0),                                           # Nonnegative constraint", 
    "    UB = c(Inf, Inf), ", "    control = list(trace = 0)", 
    "  )", "  drtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input", 
    "  drtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input", 
    "  drtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost", 
    "}", "drtsSchedule$Average_Cost <-", "  drtsSchedule$Total_Cost / drtsSchedule$Quantity           # Calculate ATC", 
    "par(mfrow = c(1, 2))", "plot(", "  drtsSchedule$Quantity,", 
    "  drtsSchedule$Total_Cost,", "  type = 'l',", "  ylim = c(0, 10000),", 
    "  xlab = \"Quantity\",", "  ylab = \"Total Cost\"", ")", 
    "plot(", "  drtsSchedule$Quantity,", "  drtsSchedule$Average_Cost,", 
    "  type = 'l',", "  ylim = c(0, 2),", "  xlab = \"Quantity\",", 
    "  ylab = \"Average Cost\"", ")", "head(drtsSchedule)"), chunk_opts = list(
        label = "drtsGraph-solution")), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "2_3_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "2_3_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6, fig.height = 6, fig.env = "figure", fig.cap = NULL, 
        fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 576, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "drtsGraph", 
        exercise = TRUE, code = c("drtsSchedule <-", "  data.frame(", 
        "    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's ", 
        "    Labor = NA,", "    Capital = NA,", "    Total_Cost = NA,", 
        "    Average_Cost = NA", "  )", "drts <- function(x) {", 
        "  100 * x[1] ^ alpha * x[2] ^ alpha                         # Define constraint", 
        "}", "# Since alpha = 1/3, the exponents sum to less than one. ", 
        "for (i in 1:nrow(drtsSchedule)) {                           # Initialize for-loop", 
        "  costMinTemp <- solnp(", "    pars = c(1, 1),                                         # Set initial pars", 
        "    fun = tc,", "    ineqfun = drts,", "    ineqLB = drtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]", 
        "    ineqUB = Inf,", "    LB = c(0, 0),                                           # Nonnegative constraint", 
        "    UB = c(Inf, Inf), ", "    control = list(trace = 0)", 
        "  )", "  drtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input", 
        "  drtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input", 
        "  drtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost", 
        "}", "drtsSchedule$Average_Cost <-", "  drtsSchedule$Total_Cost / drtsSchedule$Quantity           # Calculate ATC", 
        "par(mfrow = c(1, 2))", "plot(", "  drtsSchedule$Quantity,", 
        "  drtsSchedule$Total_Cost,", "  type = 'l',", "  ylim = c(0, 10000),", 
        "  xlab = \"Quantity\",", "  ylab = \"Total Cost\"", 
        ")", "plot(", "  drtsSchedule$Quantity,", "  drtsSchedule$Average_Cost,", 
        "  type = 'l',", "  ylim = c(0, 2),", "  xlab = \"Quantity\",", 
        "  ylab = \"Average Cost\"", ")", "head(drtsSchedule)"
        ), out.width.px = 576, out.height.px = 576, params.src = "drtsGraph, exercise = TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-irtsGraph-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-irtsGraph-code-editor`)), session)
output$`tutorial-exercise-irtsGraph-output` <- renderUI({
  `tutorial-exercise-irtsGraph-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "irtsGraph", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                   # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)               # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegativity constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
    chunks = list(list(label = "irtsGraph-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                   # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)               # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegativity constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
        opts = list(label = "\"irtsGraph-setup\""), engine = "r"), 
        list(label = "irtsGraph", code = "irtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\nirts <- function(x) {\n  100 * x[1] ^ (2*alpha) * x[2] ^ (2*alpha)                 # Define constraint\n}\n# Since alpha = 1/3, the exponents sum to more than one. \nfor (i in 1:nrow(irtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = irts,\n    ineqLB = irtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  irtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  irtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  irtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\nirtsSchedule$Average_Cost <-\n  irtsSchedule$Total_Cost / irtsSchedule$Quantity           # Calculate ATC\npar(mfrow = c(1, 2))\nplot(\n  irtsSchedule$Quantity,\n  irtsSchedule$Total_Cost,\n  type = 'l',\n  ylim = c(0, 600),\n  xlab = \"Quantity\",\n  ylab = \"Total Cost\"\n)\nplot(\n  irtsSchedule$Quantity,\n  irtsSchedule$Average_Cost,\n  type = 'l',\n  ylim = c(0, 0.5),\n  xlab = \"Quantity\",\n  ylab = \"Average Cost\"\n)\nhead(irtsSchedule)", 
            opts = list(label = "\"irtsGraph\"", exercise = "TRUE"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = structure(c("irtsSchedule <-", "  data.frame(", 
    "    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's ", 
    "    Labor = NA,", "    Capital = NA,", "    Total_Cost = NA,", 
    "    Average_Cost = NA", "  )", "irts <- function(x) {", 
    "  100 * x[1] ^ (2*alpha) * x[2] ^ (2*alpha)                 # Define constraint", 
    "}", "# Since alpha = 1/3, the exponents sum to more than one. ", 
    "for (i in 1:nrow(irtsSchedule)) {                           # Initialize for-loop", 
    "  costMinTemp <- solnp(", "    pars = c(1, 1),                                         # Set initial pars", 
    "    fun = tc,", "    ineqfun = irts,", "    ineqLB = irtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]", 
    "    ineqUB = Inf,", "    LB = c(0, 0),                                           # Nonnegativity constraint", 
    "    UB = c(Inf, Inf), ", "    control = list(trace = 0)", 
    "  )", "  irtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input", 
    "  irtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input", 
    "  irtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost", 
    "}", "irtsSchedule$Average_Cost <-", "  irtsSchedule$Total_Cost / irtsSchedule$Quantity           # Calculate ATC", 
    "par(mfrow = c(1, 2))", "plot(", "  irtsSchedule$Quantity,", 
    "  irtsSchedule$Total_Cost,", "  type = 'l',", "  ylim = c(0, 600),", 
    "  xlab = \"Quantity\",", "  ylab = \"Total Cost\"", ")", 
    "plot(", "  irtsSchedule$Quantity,", "  irtsSchedule$Average_Cost,", 
    "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
    "  ylab = \"Average Cost\"", ")", "head(irtsSchedule)"), chunk_opts = list(
        label = "irtsGraph-solution")), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "2_3_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "2_3_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6, fig.height = 6, fig.env = "figure", fig.cap = NULL, 
        fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 576, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "irtsGraph", 
        exercise = TRUE, code = c("irtsSchedule <-", "  data.frame(", 
        "    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's ", 
        "    Labor = NA,", "    Capital = NA,", "    Total_Cost = NA,", 
        "    Average_Cost = NA", "  )", "irts <- function(x) {", 
        "  100 * x[1] ^ (2*alpha) * x[2] ^ (2*alpha)                 # Define constraint", 
        "}", "# Since alpha = 1/3, the exponents sum to more than one. ", 
        "for (i in 1:nrow(irtsSchedule)) {                           # Initialize for-loop", 
        "  costMinTemp <- solnp(", "    pars = c(1, 1),                                         # Set initial pars", 
        "    fun = tc,", "    ineqfun = irts,", "    ineqLB = irtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]", 
        "    ineqUB = Inf,", "    LB = c(0, 0),                                           # Nonnegative constraint", 
        "    UB = c(Inf, Inf), ", "    control = list(trace = 0)", 
        "  )", "  irtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input", 
        "  irtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input", 
        "  irtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost", 
        "}", "irtsSchedule$Average_Cost <-", "  irtsSchedule$Total_Cost / irtsSchedule$Quantity           # Calculate ATC", 
        "par(mfrow = c(1, 2))", "plot(", "  irtsSchedule$Quantity,", 
        "  irtsSchedule$Total_Cost,", "  type = 'l',", "  ylim = c(0, 600),", 
        "  xlab = \"Quantity\",", "  ylab = \"Total Cost\"", 
        ")", "plot(", "  irtsSchedule$Quantity,", "  irtsSchedule$Average_Cost,", 
        "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
        "  ylab = \"Average Cost\"", ")", "head(irtsSchedule)"
        ), out.width.px = 576, out.height.px = 576, params.src = "irtsGraph, exercise = TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-srTotalCost-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-srTotalCost-code-editor`)), session)
output$`tutorial-exercise-srTotalCost-output` <- renderUI({
  `tutorial-exercise-srTotalCost-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "srTotalCost", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
    chunks = list(list(label = "srTotalCost-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\ncrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),          # Initialize 51 Q's \n    Labor = NA,\n    Capital = NA,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\ntc <- function(x) {\n  w * x[1] + r * x[2]                                       # Define objective \n}\ncrts <- function(x) {\n  100 * x[1] ^ alpha * x[2] ^ (1 - alpha)                   # Define constraint\n}\nfor (i in 1:nrow(crtsSchedule)) {                           # Initialize for-loop\n  costMinTemp <- solnp(\n    pars = c(1, 1),                                         # Set initial pars\n    fun = tc,\n    ineqfun = crts,\n    ineqLB = crtsSchedule$Quantity[i],                      # Set ineqLB to Q[i]\n    ineqUB = Inf,\n    LB = c(0, 0),                                           # Nonnegative constraint\n    UB = c(Inf, Inf), \n    control = list(trace = 0)\n  )\n  crtsSchedule$Labor[i] <- costMinTemp$pars[1]              # Optimal labor input\n  crtsSchedule$Capital[i] <- costMinTemp$pars[2]            # Optimal capital input\n  crtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1) # Calculate total cost\n}\ncrtsSchedule$Average_Cost <-\n  crtsSchedule$Total_Cost / crtsSchedule$Quantity           # Calculate ATC", 
        opts = list(label = "\"srTotalCost-setup\""), engine = "r"), 
        list(label = "srTotalCost", code = "srCrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),\n    Labor = NA,\n    Capital = 25,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\nsrCrts <- function(x) {\n  100 * x ^ (alpha) * 25 ^ (1 - alpha)\n}\nsrtc <- function(x) {\n  w * x + r * 25\n}\nfor (i in 1:nrow(srCrtsSchedule)) {\n  costMinTemp <- solnp(\n    pars = 1,\n    fun = srtc,\n    ineqfun = srCrts,\n    ineqLB = srCrtsSchedule$Quantity[i],\n    ineqUB = Inf,\n    LB = 0,\n    UB = Inf,\n    control = list(trace = 0)\n  )\n  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]\n  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)\n}\nsrCrtsSchedule$Average_Cost <-\n  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity\npar(mfrow = c(1, 2))\nplot(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Total_Cost,\n  type = 'l',\n  ylim = c(0, 2500),\n  xlab = \"Quantity\",\n  ylab = \"Total Cost\"\n)\nplot(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Average_Cost,\n  type = 'l',\n  ylim = c(0, 0.5),\n  xlab = \"Quantity\",\n  ylab = \"Average Total Cost\"\n)\nhead(srCrtsSchedule)", 
            opts = list(label = "\"srTotalCost\"", exercise = "TRUE", 
                exercise.reveal_solution = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = structure(c("srCrtsSchedule <-", 
    "  data.frame(", "    Quantity = seq(from = 0, to = 5000, by = 100),", 
    "    Labor = NA,", "    Capital = 25,", "    Total_Cost = NA,", 
    "    Average_Cost = NA", "  )", "srCrts <- function(x) {", 
    "  100 * x ^ (alpha) * 25 ^ (1 - alpha)", "}", "srtc <- function(x) {", 
    "  w * x + r * 25", "}", "for (i in 1:nrow(srCrtsSchedule)) {", 
    "  costMinTemp <- solnp(", "    pars = 1,", "    fun = srtc,", 
    "    ineqfun = srCrts,", "    ineqLB = srCrtsSchedule$Quantity[i],", 
    "    ineqUB = Inf,", "    LB = 0,", "    UB = Inf,", "    control = list(trace = 0)", 
    "  )", "  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]", 
    "  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)", 
    "}", "srCrtsSchedule$Average_Cost <-", "  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity", 
    "par(mfrow = c(1, 2))", "plot(", "  srCrtsSchedule$Quantity,", 
    "  srCrtsSchedule$Total_Cost,", "  type = 'l',", "  ylim = c(0, 2500),", 
    "  xlab = \"Quantity\",", "  ylab = \"Total Cost\"", ")", 
    "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Average_Cost,", 
    "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
    "  ylab = \"Average Total Cost\"", ")", "head(srCrtsSchedule)"
    ), chunk_opts = list(label = "srTotalCost-solution")), tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "2_3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "2_3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6, fig.height = 6, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 576, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, exercise.timelimit = 60, 
        exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "srTotalCost", 
        exercise = TRUE, code = c("srCrtsSchedule <-", "  data.frame(", 
        "    Quantity = seq(from = 0, to = 5000, by = 100),", 
        "    Labor = NA,", "    Capital = 25,", "    Total_Cost = NA,", 
        "    Average_Cost = NA", "  )", "srCrts <- function(x) {", 
        "  100 * x ^ (alpha) * 25 ^ (1 - alpha)", "}", "srtc <- function(x) {", 
        "  w * x + r * 25", "}", "for (i in 1:nrow(srCrtsSchedule)) {", 
        "  costMinTemp <- solnp(", "    pars = 1,", "    fun = srtc,", 
        "    ineqfun = srCrts,", "    ineqLB = srCrtsSchedule$Quantity[i],", 
        "    ineqUB = Inf,", "    LB = 0,", "    UB = Inf,", 
        "    control = list(trace = 0)", "  )", "  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]", 
        "  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)", 
        "}", "srCrtsSchedule$Average_Cost <-", "  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity", 
        "par(mfrow = c(1, 2))", "plot(", "  srCrtsSchedule$Quantity,", 
        "  srCrtsSchedule$Total_Cost,", "  type = 'l',", "  ylim = c(0, 2500),", 
        "  xlab = \"Quantity\",", "  ylab = \"Total Cost\"", 
        ")", "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Average_Cost,", 
        "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
        "  ylab = \"Average Total Cost\"", ")", "head(srCrtsSchedule)"
        ), out.width.px = 576, out.height.px = 576, params.src = "srTotalCost, exercise = TRUE, exercise.reveal_solution = TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-variableCost-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-variableCost-code-editor`)), session)
output$`tutorial-exercise-variableCost-output` <- renderUI({
  `tutorial-exercise-variableCost-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "variableCost", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\nsrCrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),\n    Labor = NA,\n    Capital = 25,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\nsrCrts <- function(x) {\n  100 * x ^ (alpha) * 25 ^ (1 - alpha)\n}\nsrtc <- function(x) {\n  w * x + r * 25\n}\nfor (i in 1:nrow(srCrtsSchedule)) {\n  costMinTemp <- solnp(\n    pars = 1,\n    fun = srtc,\n    ineqfun = srCrts,\n    ineqLB = srCrtsSchedule$Quantity[i],\n    ineqUB = Inf,\n    LB = 0,\n    UB = Inf,\n    control = list(trace = 0)\n  )\n  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]\n  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)\n}\nsrCrtsSchedule$Average_Cost <-\n  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity", 
    chunks = list(list(label = "variableCost-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\nsrCrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),\n    Labor = NA,\n    Capital = 25,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\nsrCrts <- function(x) {\n  100 * x ^ (alpha) * 25 ^ (1 - alpha)\n}\nsrtc <- function(x) {\n  w * x + r * 25\n}\nfor (i in 1:nrow(srCrtsSchedule)) {\n  costMinTemp <- solnp(\n    pars = 1,\n    fun = srtc,\n    ineqfun = srCrts,\n    ineqLB = srCrtsSchedule$Quantity[i],\n    ineqUB = Inf,\n    LB = 0,\n    UB = Inf,\n    control = list(trace = 0)\n  )\n  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]\n  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)\n}\nsrCrtsSchedule$Average_Cost <-\n  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity", 
        opts = list(label = "\"variableCost-setup\""), engine = "r"), 
        list(label = "variableCost", code = "srCrtsSchedule$Variable_Cost <- w * srCrtsSchedule$Labor\nsrCrtsSchedule$Average_Variable_Cost <-\n    srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity\nplot(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Total_Cost,\n  type = 'l',\n  ylim = c(0, 2500),\n  xlab = \"Quantity\",\n  ylab = \"Total Cost\"\n)\nlines(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Variable_Cost,\n  col = 'purple'\n)\nplot(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Average_Cost,\n  type = 'l',\n  ylim = c(0, 0.5),\n  xlab = \"Quantity\",\n  ylab = \"Average Cost\"\n)\nlines(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Average_Variable_Cost,\n  col = 'purple'\n)", 
            opts = list(label = "\"variableCost\"", exercise = "TRUE", 
                exercise.reveal_solution = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = structure(c("srCrtsSchedule$Variable_Cost <- w * srCrtsSchedule$Labor", 
    "srCrtsSchedule$Average_Variable_Cost <-", "  srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity", 
    "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Total_Cost,", 
    "  type = 'l',", "  ylim = c(0, 2500),", "  xlab = \"Quantity\",", 
    "  ylab = \"Total Cost\"", ")", "lines(", "  srCrtsSchedule$Quantity,", 
    "  srCrtsSchedule$Variable_Cost,", "  type = 'l',", "  col = 'purple'", 
    ")", "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Average_Cost,", 
    "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
    "  ylab = \"Average Cost\"", ")", "lines(srCrtsSchedule$Quantity,", 
    "      srCrtsSchedule$Average_Variable_Cost,", "      col = 'purple')"
    ), chunk_opts = list(label = "variableCost-solution")), tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "2_3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "2_3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6, fig.height = 6, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 576, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, exercise.timelimit = 60, 
        exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "variableCost", 
        exercise = TRUE, code = c("srCrtsSchedule$Variable_Cost <- w * srCrtsSchedule$Labor", 
        "srCrtsSchedule$Average_Variable_Cost <-", "    srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity", 
        "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Total_Cost,", 
        "  type = 'l',", "  ylim = c(0, 2500),", "  xlab = \"Quantity\",", 
        "  ylab = \"Total Cost\"", ")", "lines(", "  srCrtsSchedule$Quantity,", 
        "  srCrtsSchedule$Variable_Cost,", "  col = 'purple'", 
        ")", "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Average_Cost,", 
        "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
        "  ylab = \"Average Cost\"", ")", "lines(", "  srCrtsSchedule$Quantity,", 
        "  srCrtsSchedule$Average_Variable_Cost,", "  col = 'purple'", 
        ")"), out.width.px = 576, out.height.px = 576, params.src = "variableCost, exercise=TRUE, exercise.reveal_solution=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-marginalCost-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-marginalCost-code-editor`)), session)
output$`tutorial-exercise-marginalCost-output` <- renderUI({
  `tutorial-exercise-marginalCost-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "marginalCost", global_setup = structure(c("library(learnr)", 
"library(gradethis)", "gradethis_setup(exercise.reveal_solution = TRUE)", 
"knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\nsrCrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),\n    Labor = NA,\n    Capital = 25,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\nsrCrts <- function(x) {\n  100 * x ^ (alpha) * 25 ^ (1 - alpha)\n}\nsrtc <- function(x) {\n  w * x + r * 25\n}\nfor (i in 1:nrow(srCrtsSchedule)) {\n  costMinTemp <- solnp(\n    pars = 1,\n    fun = srtc,\n    ineqfun = srCrts,\n    ineqLB = srCrtsSchedule$Quantity[i],\n    ineqUB = Inf,\n    LB = 0,\n    UB = Inf,\n    control = list(trace = 0)\n  )\n  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]\n  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)\n}\nsrCrtsSchedule$Average_Cost <-\n  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity\nsrCrtsSchedule$Variable_Cost <- w * srCrtsSchedule$Labor\nsrCrtsSchedule$Average_Variable_Cost <-\n  srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity", 
    chunks = list(list(label = "marginalCost-setup", code = "library(Rsolnp)     # Don't forget to load libraries!\nalpha = 1 / 3\nw = 10\nr = 20\nsrCrtsSchedule <-\n  data.frame(\n    Quantity = seq(from = 0, to = 5000, by = 100),\n    Labor = NA,\n    Capital = 25,\n    Total_Cost = NA,\n    Average_Cost = NA\n  )\nsrCrts <- function(x) {\n  100 * x ^ (alpha) * 25 ^ (1 - alpha)\n}\nsrtc <- function(x) {\n  w * x + r * 25\n}\nfor (i in 1:nrow(srCrtsSchedule)) {\n  costMinTemp <- solnp(\n    pars = 1,\n    fun = srtc,\n    ineqfun = srCrts,\n    ineqLB = srCrtsSchedule$Quantity[i],\n    ineqUB = Inf,\n    LB = 0,\n    UB = Inf,\n    control = list(trace = 0)\n  )\n  srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]\n  srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)\n}\nsrCrtsSchedule$Average_Cost <-\n  srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity\nsrCrtsSchedule$Variable_Cost <- w * srCrtsSchedule$Labor\nsrCrtsSchedule$Average_Variable_Cost <-\n  srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity", 
        opts = list(label = "\"marginalCost-setup\""), engine = "r"), 
        list(label = "marginalCost", code = "par(mfrow = c(1, 1))\n# Find TC(Q_{i+1}) - TC(Q_{i-1}) / (2 * dQ)\nsrCrtsSchedule$Marginal_Cost <- \n  c(NA,diff(srCrtsSchedule$Total_Cost, lag = 2)/200, NA)\nplot(\n  srCrtsSchedule$Quantity,\n  srCrtsSchedule$Average_Cost,\n  type = 'l',\n  ylim = c(0, 0.5),\n  xlab = \"Quantity\",\n  ylab = \"Average/Marginal Cost\"\n)\nlines(srCrtsSchedule$Quantity,\n      srCrtsSchedule$Average_Variable_Cost,\n      col = 'purple')\nlines(srCrtsSchedule$Quantity,\n      srCrtsSchedule$Marginal_Cost,\n      col = 'red')", 
            opts = list(label = "\"marginalCost\"", exercise = "TRUE", 
                exercise.reveal_solution = "TRUE"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = structure(c("srCrtsSchedule$Marginal_Cost <- ", 
    "  c(NA,diff(srCrtsSchedule$Total_Cost, lag = 2)/200, NA)", 
    "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Average_Cost,", 
    "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
    "  ylab = \"Average/Marginal Cost\"", ")", "lines(srCrtsSchedule$Quantity,", 
    "      srCrtsSchedule$Average_Variable_Cost,", "      col = 'purple')", 
    "lines(srCrtsSchedule$Quantity,", "      srCrtsSchedule$Marginal_Cost,", 
    "      col = 'red')"), chunk_opts = list(label = "marginalCost-solution")), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "2_3_cache/html/", cache.vars = NULL, cache.lazy = TRUE, 
        dependson = NULL, autodep = FALSE, cache.rebuild = FALSE, 
        fig.keep = "high", fig.show = "asis", fig.align = "default", 
        fig.path = "2_3_files/figure-html/", dev = "png", dev.args = NULL, 
        dpi = 192, fig.ext = "png", fig.width = 6, fig.height = 6, 
        fig.env = "figure", fig.cap = NULL, fig.scap = NULL, 
        fig.lp = "fig:", fig.subcap = NULL, fig.pos = "", out.width = 576, 
        out.height = NULL, out.extra = NULL, fig.retina = 2, 
        external = TRUE, sanitize = FALSE, interval = 1, aniopts = "controls,loop", 
        warning = TRUE, error = FALSE, message = TRUE, render = NULL, 
        ref.label = NULL, child = NULL, engine = "r", split = FALSE, 
        include = TRUE, purl = TRUE, max.print = 1000, exercise.timelimit = 60, 
        exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.reveal_solution = TRUE, label = "marginalCost", 
        exercise = TRUE, code = c("par(mfrow = c(1, 1))", "# Find TC(Q_{i+1}) - TC(Q_{i-1}) / (2 * dQ)", 
        "srCrtsSchedule$Marginal_Cost <- ", "  c(NA,diff(srCrtsSchedule$Total_Cost, lag = 2)/200, NA)", 
        "plot(", "  srCrtsSchedule$Quantity,", "  srCrtsSchedule$Average_Cost,", 
        "  type = 'l',", "  ylim = c(0, 0.5),", "  xlab = \"Quantity\",", 
        "  ylab = \"Average/Marginal Cost\"", ")", "lines(srCrtsSchedule$Quantity,", 
        "      srCrtsSchedule$Average_Variable_Cost,", "      col = 'purple')", 
        "lines(srCrtsSchedule$Quantity,", "      srCrtsSchedule$Marginal_Cost,", 
        "      col = 'red')"), out.width.px = 576, out.height.px = 576, 
        params.src = "marginalCost, exercise=TRUE, exercise.reveal_solution=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.16"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.6.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["21.6.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\",\"blank\":\"blank\",\"blank_plural\":\"blanks\",\"exercisecontainsblank\":\"This exercise contains {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Please replace {{blank}} with valid code.\",\"unparsable\":\"It looks like this might not be valid R code. R cannot determine how to turn your text into a complete command. You may have forgotten to fill in a blank, to remove an underscore, to include a comma between arguments, or to close an opening <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> or <code>{<\\/code> with a matching <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> or <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>It looks like your R code contains specially formatted quotation marks or &quot;curly&quot; quotes (<code>{{character}}<\\/code>) around character strings, making your code invalid. R requires character values to be contained in straight quotation marks (<code>&quot;<\\/code> or <code>'<\\/code>).<\\/p> {{code}} <p>Don't worry, this is a common source of errors when you copy code from another app that applies its own formatting to text. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. Try deleting the special character from your code and retyping it manually.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"and\":\"and\",\"or\":\"or\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"et\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\",\"and\":\"y\",\"or\":\"o\",\"oxfordcomma\":\"\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"e\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalıştırma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"İpuçları\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki İpucu\",\"hintprev\":\"Önceki İpucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Baştan Başlamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabı onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Baştan Başlamak\",\"areyousure\":\"Baştan başlamak istediğinizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalısın\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sınav\",\"oxfordcomma\":\"\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"🏃\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"💡\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"🎯\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"📋\",\"startover\":\"⏮\",\"startovertitle\":\"Start Over\",\"continue\":\"✅\",\"submitanswer\":\"🆗\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"⬅\",\"nexttopic\":\"➡\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"🔁\"},\"text\":{\"startover\":\"⏮\",\"areyousure\":\"🤔\",\"youmustcomplete\":\"⚠️ 👉 🧑‍💻\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"💻\",\"enginecap\":\"$t(text.code) {{engine}}\",\"oxfordcomma\":\"\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\",\"oxfordcomma\":\"\"}}},\"de\":{\"translation\":{\"button\":{\"runcode\":\"Code ausführen\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Tipp\",\"hint_plural\":\"Tipps\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nächster Tipp\",\"hintprev\":\"Vorheriger Tipp\",\"solution\":\"Lösung\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"In die Zwischenablage kopieren\",\"startover\":\"Neustart\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Weiter\",\"submitanswer\":\"Antwort einreichen\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Vorheriges Kapitel\",\"nexttopic\":\"Nächstes Kapitel\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Nochmal versuchen\"},\"text\":{\"startover\":\"Neustart\",\"areyousure\":\"Bist du sicher, dass du neustarten willst? (der gesamte Lernfortschritt wird gelöscht)\",\"youmustcomplete\":\"Vervollstädinge\",\"exercise\":\"die Übung\",\"exercise_plural\":\"die Übungen\",\"inthissection\":\"in diesem Kapitel, bevor du fortfährst.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"Lücke\",\"blank_plural\":\"Lücken\",\"pleasereplaceblank\":\"Bitte ersetze {{blank}} mit gültigem Code.\",\"unparsable\":\"Dies scheint kein gültiger R Code zu sein. R kann deinen Text nicht in einen gültigen Befehl übersetzen. Du hast vielleicht vergessen, die Lücke zu füllen, einen Unterstrich zu entfernen, ein Komma zwischen Argumente zu setzen oder ein eröffnendes <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> oder <code>{<\\/code> mit einem zugehörigen <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> oder <code>}<\\/code> zu schließen.\\n\",\"and\":\"und\",\"or\":\"oder\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"ko\":{\"translation\":{\"button\":{\"runcode\":\"코드 실행\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"힌트\",\"hint_plural\":\"힌트들\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"다음 힌트\",\"hintprev\":\"이전 힌트\",\"solution\":\"솔루션\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"클립보드에 복사\",\"startover\":\"재학습\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"다음 학습으로\",\"submitanswer\":\"정답 제출\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"이전 토픽\",\"nexttopic\":\"다음 토픽\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"재시도\"},\"text\":{\"startover\":\"재학습\",\"areyousure\":\"다시 시작 하시겠습니까? (모든 예제의 진행 정보가 재설정됩니다)\",\"youmustcomplete\":\"당신은 완료해야 합니다\",\"exercise\":\"연습문제\",\"exercise_plural\":\"연습문제들\",\"inthissection\":\"이 섹션을 실행하기 전에\",\"code\":\"코드\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"퀴즈\",\"blank\":\"공백\",\"blank_plural\":\"공백들\",\"exercisecontainsblank\":\"이 연습문제에는 {{count}}개의 $t(text.blank)이 포함되어 있습니다.\",\"pleasereplaceblank\":\"{{blank}}를 유효한 코드로 바꾸십시오.\",\"unparsable\":\"이것은 유효한 R 코드가 아닐 수 있습니다. R은 텍스트를 완전한 명령으로 변환하는 방법을 결정할 수 없습니다. 당신은 공백이나 밑줄을 대체하여 채우기, 인수를 컴마로 구분하기, 또는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> , <code>{<\\/code>로 시작하는 구문을 닫는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>, <code>}<\\/code>을 잊었을 수도 있습니다.\\n\",\"and\":\"그리고\",\"or\":\"혹은\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}},\"zh\":{\"translation\":{\"button\":{\"runcode\":\"运行代码\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"提示\",\"hint_plural\":\"提示\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"下一个提示\",\"hintprev\":\"上一个提示\",\"solution\":\"答案\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"复制到剪切板\",\"startover\":\"重新开始\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"继续\",\"submitanswer\":\"提交答案\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"上一专题\",\"nexttopic\":\"下一专题\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"再试一次\"},\"text\":{\"startover\":\"重置\",\"areyousure\":\"你确定要重新开始吗? (所有当前进度将被重置)\",\"youmustcomplete\":\"你必须完成\",\"exercise\":\"练习\",\"exercise_plural\":\"练习\",\"inthissection\":\"在进行本节之前\",\"code\":\"代码\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"测试\",\"blank\":\"空\",\"blank_plural\":\"空\",\"exercisecontainsblank\":\"本练习包含{{count}}个$t(text.blank)\",\"pleasereplaceblank\":\"请在{{blank}}内填写恰当的代码\",\"unparsable\":\"这似乎不是有效的R代码。 R不知道如何将您的文本转换为完整的命令。 您是否忘了填空，忘了删除下划线，忘了在参数之间包含逗号，或者是忘了用<code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>,<code>}<\\/code>来封闭<code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code>。 or <code>{<\\/code>。\\n\",\"unparsablequotes\":\"<p>您的R代码中似乎含有特殊格式的引号，或者弯引号(<code>{{character}}<\\/code>) 在字符串前后，在R中字符串应该被直引号(<code>&quot;<\\/code> 或者 <code>'<\\/code>)包裹。<\\/p> {{code}} <p>别担心，该错误经常在复制粘贴包含格式的代码时遇到， 您可以尝试将该行中的代码替换为以下代码，也许还有其他地方需要修改。<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"and\":\"且\",\"or\":\"或\",\"listcomma\":\",\",\"oxfordcomma\":\",\"}}},\"pl\":{\"translation\":{\"button\":{\"runcode\":\"Uruchom kod\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Podpowiedź\",\"hint_plural\":\"Podpowiedzi\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Następna podpowiedź\",\"hintprev\":\"Poprzednia podpowiedź\",\"solution\":\"Rozwiązanie\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Kopiuj do schowka\",\"startover\":\"Zacznij od początku\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Kontynuuj\",\"submitanswer\":\"Wyślij\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Poprzednia sekcja\",\"nexttopic\":\"Następna sekcja\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Spróbuj ponownie\"},\"text\":{\"startover\":\"Zacznij od początku\",\"areyousure\":\"Czy na pewno chcesz zacząć od początku? (cały postęp w zadaniu zostanie utracony)\",\"youmustcomplete\":\"Musisz ukończyć\",\"exercise\":\"ćwiczenie\",\"exercise_plural\":\"ćwiczenia\",\"inthissection\":\"w tej sekcji przed kontynuowaniem\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"luka\",\"blank_plural\":\"luk(i)\",\"exercisecontainsblank\":\"To ćwiczenie zawiera {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Proszę uzupełnić {{blank}} prawidłowym kodem.\",\"unparsable\":\"Wygląda na to, że może to nie być prawidłowy kod R. R nie jest w stanie przetworzyć Twojego tekstu na polecenie. Mogłeś(-aś) zapomnieć wypełnić luki, usunąć podkreślnik, umieścić przecinka między argumentami, lub zamknąć znak <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> lub <code>{<\\/code> odpowiadającym <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> lub <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>Wygląda na to, że Twój kod zawiera szczególnie sformatowane cudzysłowy lub cudzysłowy typograficzne (<code>{{character}}<\\/code>) przy ciągach znaków, co sprawia, że kod jest niepoprawny. R wymaga cudzysłowów prostych (<code>&quot;<\\/code> albo <code>'<\\/code>).<\\/p> {{code}} <p>Nie martw się, to powszechne źródło błędów, gdy kopiuje się kod z innego programu, który sam formatuje teskt. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Spróbuj usunąć znak specjalny i wpisać do ponownie ręcznie.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"and\":\"i\",\"or\":\"lub\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.10.6.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.6.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.6.9000"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]}},"value":[{"type":"character","attributes":{},"value":["backports","base","bslib","cachem","checkmate","cli","compiler","curl","datasets","digest","ellipsis","evaluate","fastmap","gradethis","graphics","grDevices","highr","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","learnr","lifecycle","magrittr","markdown","methods","mime","parallel","promises","R6","Rcpp","rlang","rmarkdown","rprojroot","Rsolnp","rstudioapi","sass","shiny","stats","stringi","stringr","tools","truncnorm","utils","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.4.1","4.2.1","0.4.0","1.0.6","2.1.0","3.3.0","4.2.1","4.3.2","4.2.1","0.6.29","0.3.2","0.16","1.1.0","0.2.10.9000","4.2.1","4.2.1","0.9","0.5.3","1.5.4","1.6.5","0.1.4","1.8.0","1.40","1.3.0","0.10.6.9000","1.0.1","2.0.3","1.1","4.2.1","0.12","4.2.1","1.2.0.1","2.5.1","1.0.9","1.0.5","2.16","2.0.3","1.16","0.14","0.4.2","1.7.2","4.2.1","1.7.8","1.4.1","4.2.1","1.0-8","4.2.1","2.5.0","0.32","1.8-4","2.3.5"]}]}]}
</script>
<!--/html_preserve-->
</div>
</div>

</article> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h1 class="title toc-ignore" style="display:none;">2.3 Cost Curves</h1>
<h4 class="author"><em>Created by <a
href="http://www.github.com/bangecon">Jim Bang</a></em></h4>
<address class="author_afil">
<a href="http://www.sau.edu">St. Ambrose
University</a><br><a class="author_email" href="mailto:#"><a
href="mailto:BangJamesT@sau.edu"
class="email">BangJamesT@sau.edu</a></a>
</address>
<h4 class="date"><em>03 Apr 2023</em></h4>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</main> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>

---
title: "1.4 Rational Consumer Choice"
output: 
  learnr::tutorial: 
    progressive: true
runtime: shiny_prerendered
author: 
  name: "Created by [Jim Bang](http://www.github.com/bangecon)"
  email: BangJamesT@sau.edu
  affiliation: "[St. Ambrose University](http://www.sau.edu)"
date: "`r format(Sys.Date(), '%d %b %Y')`"
---

<style type="text/css">
h1{font-size: 24pt}
h2{font-size: 20pt}
h3{font-size: 18pt}
h4,h5,h6{font-size: 16pt}
body{font-size: 16pt}
#doc-metadata {
  margin-bottom: 10px;
  font-size: 0.66em;
}
</style>

```{r setup, include = FALSE}
library(learnr)
library(gradethis)
gradethis_setup()
tutorial_options(exercise.eval = TRUE, exercise.reveal_solution = TRUE)
knitr::opts_chunk$set(echo = FALSE, fig.align = "center", fig.height = 6, fig.width = 6)
knitr::include_graphics
par(mar = c(5, 4, 1, 1))
```

## Rational Choice

### Overview

A *rational* consumer chooses the *most preferred* bundle that lies within their *budget constraint*. 

When we represent preferences with a *utility function*, that bundle *maximizes utility* subject to the budget constraint. 

Solution methods: 

1. Graphical
2. Analytical
3. Computational

### Example 

The following example solves the utility maximization problem involving a two-good Cobb-Douglass utility function with $\alpha = 0.25$, $p_1 = 1.5$, $p_2 = 1$, and $m = 100$.  

$$\max_x \bigg\{ U(x_1, x_2) = x_1^{0.25}x_2^{0.75} \bigg\}$$
$$\text{s.t.: }1.5x_1+x_2 \le 100$$

## Graphical Solution

The graphical solution shows the intuition for the equilibrium, which is: 

1. The *consumer's* willingness to trade off $x_1$ and $x_2$ (the MRS, or slope of the indifference curve) equals the *market's* willingness to trade off $x_1$ and $x_2$ (the relative price of good 1 to good 2, or the slope of the budget line); 
$$\frac{MU_1}{MU_2}=\frac{p_1}{p_2}$$
2. The consumer exactly spends their budgeted income. 
$$p_1x_1 + p_2x_2 = m$$

<details style="line-height:105%"><summary>Click here to view the code for the graph.</summary>
`a = 0.25; p1 = 1.5; p2 = 1; m = 100`<br>
`ux <- function(x) -x[1] ^ (a) * x[2] ^ (1 - a)`<br>
`bc <- function(x) p1 * x[1] + p2 * x[2]`<br>
`eq <- solnp(c(1, 1), ux, ineqfun = bc, ineqLB = 0, ineqUB = m,`<br>
&nbsp;&nbsp;`LB = c(0, 0), UB = c(Inf, Inf), control = list(trace = 0))`<br>
`curve((-ux(eq$pars))^(1/(1-a)) / (x^(a/(1-a))),`<br>
&nbsp;&nbsp;`from = 0, to = m / p1, ylim = c(0, m / p2),`<br>
&nbsp;&nbsp;`xlab = expression(x[1]), ylab = expression(x[2]), col = 'darkgreen')`<br>
`abline(m / p2, -p1 / p2, col = 'red')`<br>
`points(eq$pars[1], eq$pars[2], col = 'blue', pch = 20)`<br>
`curve((1.1 * -ux(eq$pars))^(1/(1-a)) / (x^(a/(1-a))),`<br>
&nbsp;&nbsp;`add = TRUE, col = 'darkgreen', lty = 'dashed')`<br>
`curve((0.9 * -ux(eq$pars))^(1/(1-a)) / (x^(a/(1-a))),`<br>
&nbsp;&nbsp;`add = TRUE, col = 'darkgreen', lty = 'dashed')`<br>
`text(eq$pars[1] + 4, eq$pars[2] + 4,`<br>
&nbsp;&nbsp;`paste0('x = (', round(eq$pars[1], 2), ', ',` <br>
&nbsp;&nbsp;&nbsp;&nbsp;`round(eq$pars[2], 2), ')\nu(x) = ', round(-ux(eq$pars), 2)))`<br>
`text(50, (1.1 * -ux(eq$pars))^(1/(1-a)) / (50^(a/(1-a))) + 3,`<br>
&nbsp;&nbsp;`paste0('u(x) = ', round(1.1 * -ux(eq$pars), 2)))`<br>
`text(50, (0.9 * -ux(eq$pars))^(1/(1-a)) / (50^(a/(1-a))) + 3,`<br>
&nbsp;&nbsp;`paste0('u(x) = ', round(0.9 * -ux(eq$pars), 2)))` <br>
</details>

```{r, fig.width=6, fig.height=8, fig.align='center', out.width = '75%'}
a = 0.25; p1 = 1.5; p2 = 1; m = 100
ux <- function(x) -x[1] ^ (a) * x[2] ^ (1 - a)
bc <- function(x) p1 * x[1] + p2 * x[2]
eq <- solnp(c(1, 1), ux, ineqfun = bc, ineqLB = 0, ineqUB = m,
  LB = c(0, 0), UB = c(Inf, Inf), control = list(trace = 0))
curve((-ux(eq$pars))^(1/(1-a)) / (x^(a/(1-a))),
  from = 0, to = m / p1, ylim = c(0, m / p2),
  xlab = expression(x[1]), ylab = expression(x[2]), col = 'darkgreen')
abline(m / p2, -p1 / p2, col = 'red')
points(eq$pars[1], eq$pars[2], col = 'blue', pch = 20)
curve((1.1 * -ux(eq$pars))^(1/(1-a)) / (x^(a/(1-a))),
  add = TRUE, col = 'darkgreen', lty = 'dashed')
curve((0.9 * -ux(eq$pars))^(1/(1-a)) / (x^(a/(1-a))),
  add = TRUE, col = 'darkgreen', lty = 'dashed')
text(eq$pars[1] + 4, eq$pars[2] + 4,
  paste0('x = (', round(eq$pars[1], 2), ', ', 
    round(eq$pars[2], 2), ')\nu(x) = ', round(-ux(eq$pars), 2)))
text(50, (1.1 * -ux(eq$pars))^(1/(1-a)) / (50^(a/(1-a))) + 3,
  paste0('u(x) = ', round(1.1 * -ux(eq$pars), 2)))
text(50, (0.9 * -ux(eq$pars))^(1/(1-a)) / (50^(a/(1-a))) + 3,
  paste0('u(x) = ', round(0.9 * -ux(eq$pars), 2))) 
```

## Analytical Approach

### Five Key Steps

1. Rearrange the constraint to be something equal to *zero* when it binds. 
2. Define the Lagrangean: add $\lambda \cdot [constraint]$ to the objective function (remember, it's zero when it binds, so you're not really adding anything!).
3. Take derivatives with respect to the choice variables ($x_1$ and $x_2$) *and* $\lambda$. 
4. Set the derivatives equal to zero. 
5. Solve the system of equations for $x_1$, $x_2$ and $\lambda$. 

The "Lagrangian" function for our example is: 

$$\mathcal{L} = x_1^{0.25}x_2^{0.75} + \lambda (100 - 1.5x_1 - x_2)$$

<details style="line-height:105%"><summary>Click here to view the steps for solving the problem analytically.</summary>
For the constrained optimization problem given above, use the `deriv` function to:

1. Define a yac_symbol object for the utility function and the Lagrangian;
2. Find the gradient with respect to $x_1$, $x_2$, *and* $\lambda$;

Wrap the function obtaining the derivatives in "()" so that it displays in the output. 
</details>

### First-Order Conditions

Setting the derivatives of the Lagrangean equal to zero finds the "first-order conditions." These conditions find the "critical values" where the Lagrangean switches from increasing to decreasing (or vice-versa) corresponding to maximum (minimum) values. 

Run the following code to derive the first order conditions (first derivative - changes with respect to each variable - equal to zero) for the Lagrangean function. 

```{r foc, exercise = TRUE, exercise.reveal_solution = TRUE}
library(Ryacas)
u <- ysym('x1^(0.25) * x2^(0.75)')          # Define u(x) as a yac_symbol
L <- u + ysym('lambda*(100 - 1.5*x1 - x2)') # Define L(x) as a yac_symbol
dL <- deriv(L, c('x1', 'x2', 'lambda'))     # Take the derivatives - "gradient"
dL
```

```{r foc-solution}
library(Ryacas)
u <- ysym('x1^(0.25) * x2^(0.75)')
L <- u + ysym('lambda*(100 - 1.5*x1 - x2)')
dL <- deriv(L, c('x1', 'x2', 'lambda'))
dL
```

```{r foc-check}
grade_code()
```

```{r, eval=TRUE}
u <- ysym('x1^(0.25) * x2^(0.75)')
L <- u + ysym('lambda*(100 - 1.5*x1 - x2)')
dL <- c(deriv(L, 'x1'), deriv(L, 'x2'), deriv(L, 'lambda'))
```

$$`r tex(dL[[1]])` = 0 \text{ (w.r.t. good 1)}$$
$$`r tex(dL[[2]])` = 0 \text{ (w.r.t. good 2)}$$
$$`r tex(dL[[3]])` = 0 \text{ (w.r.t. }\lambda)$$

### Solving for the Equilibrium

The basic recipe: 

1. Solve the first-order conditions with respect to $x_1$ and $x_2$ for $\lambda$.
2. Combine these two conditions to form the MU-per dollar or MRS condition. 
$$\frac{MU_1}{p_1} = \frac{MU_2}{p_2} = \lambda \text{, or}$$
Rearranging, this is equivalent to: 
$$\frac{MU_1}{MU_2} = \frac{p_1}{p_2}.$$
3. Solve the MU/dollar or MRS condition **and** the budget constraint for $x_2$. 
4. Combine these two equal expressions and solve for $x_1^*$.
5. Repeat 3 and 4 **or** substitute $x_1^*$ to solve for $x_2^*$
6. Substitute $x_1^*$ and $x_2^*$ in the first-order conditions to find $\lambda$.

### The MRS Condition

<details style="line-height:105%"><summary>Click here to view the steps for solving the problem analytically.</summary>
Derive the $MRS$ of the example with the following steps: 

1. Solve the first-order conditions with respect the $x_1$ for $\lambda$ using `solve` from `Ryacas`. Pipe this forward to `y_rmvars()` to remove the `lambda ==` and multiply the result by `p1`. Name this object `MU1`. <br>
2. Convert the result to a string with `yac_str` and cancel terms with `Simplify()`. Convert the result back to a `yac_symbol` with `ysym`. 
3. Repeat 1 and 2 for the first-order condition with respect to $x_2$ and name it `MU2`. 
4. Divide `MU1/MU2` to get the MRS. 
</details>

```{r MRS, exercise = TRUE, exercise.reveal_solution = TRUE, exercise.lines = 12}
MU <- deriv(u, c('x1', 'x2'))  # Derive the marginal utilities (could get from L)
MRS <- yac_str(MU[1]/MU[2]) |> # Calculate, simplify, and format the MRS = MU1/MU2 
  Simplify() |> 
  ysym()
```

```{r MRS-solution}
MU <- deriv(u, c('x1', 'x2'))
MRS <- yac_str(MU[1]/MU[2]) |> 
  Simplify() |> 
  ysym()
```

```{r MRS-check}
grade_this({if (!inherits(.result, c("yac_symbol"))) {
    fail("Your class of your answer should be a yac_symbol")}
  if (.result$yacas_cmd != "x2/(3*x1)") { 
    fail("The MRS should be x2/(3*x1)") }
  pass()
})
```

```{r, eval=TRUE}
MU <- deriv(u, c('x1', 'x2'))
MRS <- yac_str(MU[1]/MU[2]) |> 
  Simplify() |> 
  ysym()
```

$$MRS = `r tex(MRS)` = \frac{p_1}{p_2}$$
### Solving for Consumption

<details style="line-height:105%"><summary>Click here to view the steps for solving the problem analytically.</summary>
`Solve()` can take up to three arguments:

1. The right-hand side expression, formatted as a `yac_symbol` (required). 
2. The left-hand side expression, which may be either an equation or numerical value (default is zero). 
3. The variable to solve for. 

In addition, each of these arguments may be vectors, so you may solve multiple equations for multiple variables. 

The solution for $x_1$ will still contain the variable $x_2$ even though we have found the numerical solution for $x_2$. We can clean this up using `with_value()`. 
</details>

Solve for the optimal $x_1^*$ and $x_2^*$. 

```{r solution, exercise = TRUE, exercise.reveal_solution = TRUE}
xStar <- 
  solve(c(MRS, dL[[3]]), # Simultaneously solve the MRS condition and Budget
    c(p1 / p2, 0),       # Set the MRS equal to p1/p2 and Budget to zero
    c('x1', 'x2')) |>    # Solve for x1 and x2
  y_rmvars()             # Remove the variables (x1 = ...) from the expression
xStar <- 
  with_value(xStar,      # Make a value replacement in the solution
    'x2', xStar[2]) |>   # Replace 'x2' with its solution (element 2 of xStar)
  as_r()                 # Reformat as a numerical R object
```

```{r solution-solution}
xStar <- 
  solve(c(MRS, dL[[3]]), 
    c(p1/p2, 0), c('x1', 'x2')) |> 
    y_rmvars()
xStar <- 
  with_value(xStar, 
    'x2', 
    xStar[2]) |>
  as_r()
```

```{r solution-check}
grade_this({if (!inherits(.result, c("yac_symbol"))) {
    fail("Your class of your answer should be a yac symbol")}
  if (.result != 75) { 
    fail("The optimal quantity of x2 should be 75") }
  pass()
})
```

```{r}
xStar <- solve(c(MRS, dL[[3]]), c(p1/p2, 0), c('x1', 'x2')) |> 
  y_rmvars()
xStar <- with_value(xStar, 'x2', xStar[2]) |>
  as_r()
```

### Solving for $\lambda$ 

1. Substitute the value in the first position

```{r lambda, exercise = TRUE}
lambda <- solve(dL[1], 'lambda') |> # Solve the FOC with respect to x1 for lambda
    y_rmvars() |>                   # Remove the left-hand side (lambda = ...)
    with_value('x1', xStar[1]) |>   # Substitute the solution for x1 for x1
    with_value('x2', xStar[2]) |>   # Substitute the solution for x2 for x2
    as_r()                          # Reformat as a numerical R object
```

```{r lambda-solution}
lambda <- solve(dL[1], 'lambda') |> 
    y_rmvars() |>
    with_value('x1', xStar[1]) |>
    with_value('x2', xStar[2]) |>
    as_r()
```

```{r lambda-check}
grade_code()
```

```{r}
lambda <- solve(dL[1], 'lambda') |> 
    y_rmvars() |>
    with_value('x1', xStar[1]) |>
    with_value('x2', xStar[2]) |>
    as_r()
```

If you print the solution for all three choice variables, it will look like this: 

$(`r c(xStar[1], xStar[2], lambda)`)$

## Computational Solution

Not gonna lie: part of the point of going through the solution analytically was to show you what a pain in the tuchus it can be! (It's not necessarily better doing it on pencil-and-paper "by hand" either!)

Now, we'll set that aside and let the computer crunch the numbers. One downside of this is that we'll lose some of the intuition of the expressions we derived in the analytic solution.

### Setup

Set up the solution by defining the following

1. A utility function, `ux` defined as a `function(x)` object where `x = c(x[1], x[2])`. <br>
Note: most optimization functions find the function minimum by default. Some have an option that switches from minimization to maximization; `solnp` does *not*, so we will minimize the *negation* of the utility function (i.e. put a "-" sign in front).
2. The budget constraint, `bc` defined similarly to `ux`. 
3. The parameters `a`, `p1`, `p2`, and `m` using the numerical values from the example.

```{r computeSetup, exercise = TRUE, exercise.reveal_solution = TRUE}

```

```{r computeSetup-solution}
library(Rsolnp)
a = 0.25; p1 = 1.5; p2 = 1; m = 100    # Set exogenous parameter values
ux <- function(x) -x[1]^a * x[2]^(1-a) # Define the objective to MINIMIZE (minus-u)
bc <- function(x) p1*x[1] + p2*x[2]    # Define the budget constraint
```

```{r computeSetup-check}
grade_code() 
```

### Solving Constrained Optimization in R: `Rsolnp::solnp()`

Once we've defined these values, the solution for the optimal consumption bundle involves a single function, `solnp()`, from the `Rsolnp` package (which imports automatically with our `MicroWithR`, but still needs to be loaded using `library()`)

The required arguments for this function are (in order): 

1. `pars`: the starting values (an initial "guess") for $x$ (which must be positive - and usually small - for economically-sensible answers);
2. `fun`: the function to be *minimized* (the *disutility* function, `ux`); 

For constrained optimization (as we currently face) we also need: 

3. `ineqfun`: the inequality constraint function
4. `ineqLB`: the lower bound of `ineqfun` (for the budget constraint, $-\infty$ coded as `-Inf`)
5. `ineqUB`: the upper bound of `ineqfun` (for the budget constraint, income - `m`).

Finally, we often forget to constrain the solution to positive quantities (effectively no short-selling of consumption!). 

6. `LB`: the lower bound on the parameters (`x1` and `x2`), which in most economic problems we set as a vector of zeros - c(0, 0) for two-good consumer choice; c(0, 0, 0) for three goods, etc.
7. `UB`: the upper bound on the parameters, which in most problems we leave unspecified and defaults to no upper bound or `UB = c(Inf, Inf)`.  
8. `control`: a list of technical control parameters, as well as whether to show the "trace" output of objective function and parameter values at each iteration (`control = list(trace = 0)` to hide). 

The output of the `solnp` function is a `list` object. You can view all of the components of a list by just typing the name of the object. You can view (or extract for other calculations) individual components of a list by specifying the list name and the name of the component within the list separated by `$`. For example, `eq$pars` gives you the solutions of the x values in a `solnp` solution named `eq`. 

### Equilibrium Consumption

Setting up the problem is the key: once you do this (carefully!) there is only one line of code to get the solution. Do this, then print the elements of the solution corresponding to the `pars` (x values) `lagrange` (Lagrange multiplier), and the final value of the objective function. 

Hint: you defined the utility function as `ux = function(x) {...}`. Evaluate `ux` at the solution `pars`. Recall that the true value of *utility* is the negative of the *disutility* function we used in the optimization. 

Note: The true value of the Lagrange multiplier for the *utility-maximization* problem is also the negative of the Lagrange of the *disutility-minimization* problem. 

```{r computeSolve, exercise = TRUE, exercise.setup = 'computeSetup-solution'}

```

```{r computeSolve-solution}
eq <- solnp(c(1, 1), ux, ineqfun = bc, ineqLB = 0, ineqUB = m,
  LB = c(0, 0), UB = c(Inf, Inf))
eq$pars
-eq$lagrange
-ux(eq$pars)
```

```{r computeSolve-check}
grade_this({if (!inherits(.result, c("list"))) {
    fail("Your class of your answer should be a list")}
  if (round(-tail(.result$values, 1), 1) != 51.5) { 
    fail("The maximum of the utility function should be about 51.5") }
  pass()
})
```

```{r}
a = 0.25; p1 = 1.5; p2 = 1; m = 100
ux <- function(x) - x[1] ^ (a) * x[2] ^ (1 - a)
bc <- function(x) p1 * x[1] + p2 * x[2]
eq <- solnp(c(0.01, 0.01), ux, LB = c(0, 0), UB = c(Inf, Inf), 
                     ineqfun = bc, ineqLB = 0, ineqUB = m)
```

Note that the intuition from the analytical solution tells us that the "true" answer is $x_1 = 50/3 \approx 16.667$ and $x_2 = 75$ to ensure that this consumer spends 25% of their planned budget for the two goods on good 1, or one-third as much as they spend on good 2. Computational methods only give approximate answers, so it's good to double check! 

### Graph of the Equilibrium

We can also graph the equilibrium. 

The trick to graphing the equilibrium is graphing the right indifference curve. We want to make sure we graph the indifference curve where $u(x) = u^*$, where $u^*$ is the value of the utility at the optimal consumption bundle. 

Since $u^*$ is just a number (once we solve for the optimal x), just rearrange $u(x_1, x_2) = u^*$ to get $x_2 = f(x_1; u^*)$. Doing this by hand is not too bad for most examples if you remember some algebra for exponents and other elementary functions, but you can also use `Ryacas`.

1. Graph the indifference curve ($x_2 = f(x_1^*; u^*)$, in `'dark green'`) using x-limits (`xlim`) equal to $(0, m/p_1)$ and y-limits (`ylim`) equal to $(0, m/p_2)$ and axis labels (`xlab` and `ylab`) of $x_1$ and $x_2$.
2. Add the budget constraint using `abline` in `'red'`. 
3. Add a point for equilibrium using `points` in `'blue'`.

```{r graph, exercise = TRUE, exercise.reveal_solution = TRUE, fig.height=6.5, fig.width=4.5, fig.align='center'}

```

```{r graph-solution}
curve((-ux(eq$pars))^(1/(1-a))/(x^(a/(1-a))), # x2 = f(x1, u)
  from = 0, to = m/p1, ylim = c(0, m/p2),              # x domain; y-axis limits
  xlab = expression(x[1]), ylab = expression(x[2]),    # Fancy axis labels
  col = 'darkgreen')
curve(m/p2 - x*(p1/p2), add = TRUE, col = 'red')       # Add a red budget line 
points(eq$pars[1], eq$pars[2],       # Add a point at x*
       col = 'blue', pch = 20)
```

```{r graph-check}
grade_this({if (!inherits(.result, c("list"))) {
    fail("Your class of your answer should be a list")}
  if (round(-tail(.result$values, 1), 1) != 51.5) { 
    fail("The maximum of the utility function should be about 51.5") }
  pass()
})
```

---
title: "2.2 Cost Minimization"
output: 
  learnr::tutorial: 
    progressive: true
runtime: shiny_prerendered
author: 
  name: "Created by [Jim Bang](http://www.github.com/bangecon)"
  email: BangJamesT@sau.edu
  affiliation: "[St. Ambrose University](http://www.sau.edu)"
date: "`r format(Sys.Date(), '%d %b %Y')`"
---

<style type="text/css">
h1{font-size: 24pt}
h2{font-size: 20pt}
h3{font-size: 18pt}
h4,h5,h6{font-size: 16pt}
body{font-size: 16pt}
#doc-metadata {
  margin-bottom: 10px;
  font-size: 0.66em;
}
</style>

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
gradethis_setup(exercise.reveal_solution = TRUE, exercise.eval = TRUE)
knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)
```

## Overview

Goal: Minimize costs for any (each?) given quantity 

Constraint: Quantity produced with available technology

Endogenous (Strategic) Variables: Choice of inputs

Exogenous Variables (Parameters): Market input prices, technology

### Isocost Lines

Isocost lines resemble budget lines from the consumer problem. 

$$TC = wL + rK$$

Since total cost is the *objective* the firm sets out to minimize, we do not set a given value for the left-hand side. 

The right-hand side consists of labor costs (price per unit labor, i.e. wage, times the quantity of labor hired) plus capital costs (price per unit capital, i.e. rent, times the quantity of capital rented). 

```{r costExpr, echo=FALSE}
question("What is the syntax for the `expr` argument to plot an isocost curve with the `curve()` function, where the wage is 10, rental price of capital is 20, and total cost is 1000?",
    answer("`10*L + 20*K`"),
    answer("`1000 - 10*x - 20*y`"),
    answer("`50 - 0.5*x`", correct = TRUE),
    answer("`50 - 2*L`"),
    allow_retry = TRUE
  )
```

### Plotting Isocost Lines

Solving for $K$, the isocost line becomes

$$K = \frac{TC}{r} - \frac{w}{r}L.$$

Plot the isocost lines for $TC = \{500, 750, 1000\}$ for $0 \le L \le 100$ given a market wage of 10 and a market rental price of capital of 20. Orient the quantity of labor on the horizontal axis (labeled "Labor") and quantity of capital on the vertical axis (labeled "Capital").

```{r isocost, exercise = TRUE}

```


```{r isocost-solution}
curve(50 - x / 2,
      from = 0,
      to = 100,
      ylim = c(0, 50),
      xlab = "Labor",
      ylab = "Capital")
curve(37.5 - x / 2,
      from = 0,
      to = 75,
      add = TRUE)
curve(25 - x / 2,
      from = 0,
      to = 50,
      add = TRUE)
arrows(x0 = 50,
       y0 = 25,
       x1 = 25,
       y1 = 12.5)
```


```{r isocost-check}
grade_this({if (!inherits(.result, c("list"))) {
    fail("Your class of your answer should be a list")}
  if (round(.result$y[2], 3) != 24.75) { 
    fail("The second y value should equal 24.75.") }
  pass()
})
```

### Isoquant *Constraint*

Suppose that the firm wants to produce 2,500 units of output. Add the isoquant for the Cobb-Douglas production function from the previous section to the graph you started above. 

$$f(L, K) = 100L^{1/3}K^{2/3} = 2500$$

```{r quantExpr, echo=FALSE}
question("Which of the following is NOT a correct syntax for the `expr` argument to plot an isoquant curve with the `curve()` function, where production is described by a Cobb-Douglass production function with labor-share of one-third, a total factor productivity of 100, and total output of 2,500?",
    answer("100*x^(`1/3`) * y^(`2/3`)", correct = TRUE),
    answer("125/(x^0.5)"),
    answer("(2500/x^(`1/3`))^(3/2)"),
    answer("25^(3/2) * x^(-3/2)"),
    allow_retry = TRUE
  )
```

### Plotting Isoquants

```{r isoquant, exercise = TRUE}

```

```{r isoquant-solution}
curve((2500 / (100*x^(1/3)))^(3/2), 
      from = 0, 
      to = 75,
      ylim = c(0, 75),
      xlab = "Labor",
      ylab = "Capital")
```

```{r isoquant-check}
grade_this({if (!inherits(.result, c("list"))) {
    fail("Your class of your answer should be a list")}
  if (round(.result$y[2], 3) != 176.777) { 
    fail("The second y value should equal 176.777.") }
  pass()
})
```

## Graphical Approach

From our graphs, it appears that this firm would minimize its cost of producing 2500 units by hiring about 25 units of labor and renting about 25 units of capital at a cost of 75. 

```{r}
curve(37.5 - x / 2,
      from = 0,
      to = 75, 
      ylim = c(0,75),
      xlab = "Labor", 
      ylab = "Capital")
curve((2500 / (100*x^(1/3)))^(3/2), add = TRUE)
segments(x0 = 25, y0 = 0, x1 = 25, y1 = 25, lty = 'dashed')
segments(x0 = 0, y0 = 25, x1 = 25, y1 = 25, lty = 'dashed')
```

## Analytical Approach

### Consumer Expenditure Minimization Redux

The solution to the cost-minimization problem mirrors the expenditure minimization problem we used to help decompose the effect of a price change into income and substitution effects. In that context, we defined $\tilde{x}$ to be the consumption bundle that minimized expenditures subject to remaining on the same level of utility as the original equilibrium before the price change. 

$$min_x \bigg\{p_1x_1 + p_2x_2 \bigg\}$$

$$\text{s.t. } u_0^* - u(x_1, x_2) \le 0$$

### Cost Minimization - Setup

In the case of cost minimization, the basic structure is similar, except that the firm uses its "expenditures" (costs) to "buy" (hire/rent) inputs to gain a benefit in the form of output. Formally, the firm solves: 

$$min_{L,K} \bigg\{wL + rK \bigg\}$$

$$\text{s.t. } y^* - f(L, K) \le 0$$

Recall the five key steps for constrained optimization problems: 

1. Rearrange the constraint to be something equal to *zero* when it binds. 
2. Define the Lagrangean (since this is minimization the constraint portion of the Lagrangean will be *less than* or equal to zero).
3. Take derivatives with respect to the choice variables (including $\lambda$). 
4. Set the derivatives equal to zero. 
5. Solve for all choice variables. 

The Lagrangean for the firm with parameters defined from our example is: 

$$\mathcal{L} = L + 2K + \lambda(2500 - 100L^{1/3}K^{2/3})$$

Run the code chunk below to obtain the first-order conditions for the cost minimization problem. 

1. Define a `yac_symbol` object for the Lagrangean (name it "G" to avoid conflict withthe "L" for labor);
2. Find the derivatives with respect to $L$, $K$, and $\lambda$;

```{r foc, exercise = TRUE, exercise.reveal_solution = TRUE}
library(Ryacas)
library(Deriv)
w = 10
r = 20
G <- ysym('10*L + 20*K + lambda*(2500 - 100*L^(1/3) * K^(2/3))')
dG <- deriv(G, c('L', 'K', 'lambda'))
```

```{r foc-solution}
library(Ryacas)
library(Deriv)
w = 10
r = 20
G <- ysym('10*L + 20*K + lambda*(2500 - 100*L^(1/3) * K^(2/3))')
dG <- deriv(G, c('L', 'K', 'lambda'))
```

```{r foc-check}
grade_this({if (!inherits(.result, c("yac_symbol"))) {
    fail("Your class of your answer should be a list")}
  if (.result != 'y: 2500-100*L^(1/3)*K^(2/3)') { 
    fail("The third element of the gradient should equal the production function.") }
  pass()
})
```

Setting the derivatives of the Lagrangean equal to zero finds the "first-order conditions." These conditions find the "critical values" where the Lagrangean switches from increasing to decreasing (or vice-versa) corresponding to maximum (minimum) values. 

```{r}
library(Ryacas)
library(Deriv)
G <- ysym('10*L + 20*K + lambda*(2500 - 100*L^(1/3) * K^(2/3))')
dG <- deriv(G, c('L', 'K', 'lambda'))
```

$$`r tex(dG[[1]])` = 0 \text{ (w.r.t. L)}$$
$$`r tex(dG[[2]])` = 0 \text{ (w.r.t. K)}$$
$$`r tex(dG[[3]])` = 0 \text{ (w.r.t. }\lambda)$$

### The Marginal Rate of Technical Substitution (MRTS)

Combining the first-order conditions with respect to $x_1$ and $x_2$, we get the "Cost per Marginal Product" condition: 

$$\frac{w}{MP_L} = \frac{r}{MP_K} = \lambda \text{, or}$$

$$MRTS_{LK} = \frac{MP_L}{MP_K} = \frac{w}{r}.$$

Run the code chunk below to derive the $MRTS$ of the example with the following steps: 

1. Solve the first-order condition with respect to `L` for $\lambda$ using `Ryacas::solve()`. Pipe the result to `y_rmvars()` to remove the `lambda==` from the LHS, and divide the result by `w`. <br>
This will give you $1/MP_L$, so we will name it `MPLinv`.
2. Convert MLPinv to a character string with `yac_str()` and pipe the result forward to `Deriv::Simplify()` before converting it back to a `yac_symbol` with `ysym()`
3. Repeat steps 1 and 2 for the first order condition with respect to `K` and name the result `MPKinv`. 
4. Get the $MRTS = MPL/MPK$ by dividing `MPKinv` by `MPLinv`. 

```{r MRTS, exercise = TRUE, exercise.reveal_solution = TRUE, exercise.lines = 12, exercise.setup = "foc"}
MPLinv <- solve(dG[[1]], 'lambda') |>
  y_rmvars()/w 
MPL <- yac_str(1/MPLinv) |>
  Simplify() |>
  ysym()
MPKinv <- solve(dG[[2]], 'lambda') |>
  y_rmvars()/r
MPK <- yac_str(1/MPKinv) |>
  Simplify() |>
  ysym()
MRTS <- yac_str(MPL/MPK) |> 
  Simplify() |> 
  ysym()
```

```{r MRTS-solution}
MPLinv <- solve(dG[[1]], 'lambda') |>
  y_rmvars()/w 
MPL <- yac_str(1/MPLinv) |>
  Simplify() |>
  ysym()
MPKinv <- solve(dG[[2]], 'lambda') |>
  y_rmvars()/r
MPK <- yac_str(1/MPKinv) |>
  Simplify() |>
  ysym()
MRTS <- yac_str(MPL/MPK) |> 
  Simplify() |> 
  ysym()
```

```{r MRTS-check}
grade_this({if (!inherits(.result, c("yac_symbol"))) {
    fail("Your class of your answer should be a list")}
  if (.result != 'y: K/(2*L)') { 
    fail("The MRTS should equal K/2L.") }
  pass()
})
```

```{r}
MPLinv <- solve(dG[[1]], 'lambda') |>
  y_rmvars()/w 
MPL <- yac_str(1/MPLinv) |>
  Simplify() |>
  ysym()
MPKinv <- solve(dG[[2]], 'lambda') |>
  y_rmvars()/r
MPK <- yac_str(1/MPKinv) |>
  Simplify() |>
  ysym()
MRTS <- yac_str(MPL/MPK) |> 
  Simplify() |> 
  ysym()
```

$$`r tex(MRTS)` = w/r$$

### Solving for Input Levels

Run the following code

```{r solution, exercise = TRUE, exercise.lines = 12, exercise.setup = "MRTS"}
Lstar <- with_value(dG[[3]], 'K',  simplify(y_rmvars(solve(MRTS, w/r, 'K')))) |>
  solve('L') |>
  y_rmvars() |> 
  as_r()
Kstar <- with_value(solve(MRTS, w/r, 'K'), 'L', Lstar) |> 
  y_rmvars() |> 
  as_r()
lambda <- with_value(dG[[1]], 'K', as_r(y_rmvars(Kstar))) |>
  with_value('L', as_r(y_rmvars(Lstar))) |>
  solve('lambda') |>
  y_rmvars() |>
  as_r()
```

```{r solution-solution}
Lstar <- with_value(dG[[3]], 'K',  y_rmvars(solve(MRTS, w/r, 'K'))) |>
  solve('L') |>
  y_rmvars() |> 
  as_r()
Kstar <- with_value(solve(MRTS, w/r, 'K'), 'L', Lstar) |> 
  y_rmvars() |> 
  as_r()
lambda <- with_value(dG[[1]], 'K', as_r(y_rmvars(Kstar))) |>
  with_value('L', as_r(y_rmvars(Lstar))) |>
  solve('lambda') |>
  y_rmvars() |>
  as_r()
```


```{r solution-check}
grade_this({if (!inherits(.result, c("numeric"))) {
    fail("Your class of your answer for lambda should be a number")}
  if (.result != 0.03) { 
    fail("Lambda should equal 0.03.") }
  pass()
})
```

What does $\lambda$ *represent*?

## Computational Approach

### Expenditure Minimization

Suppose that we wanted to find the expenditure minimizing way to achieve 2500 "utils" of utility for a consumer whose preferences follow a Cobb-Douglas utility function and prices of $x_1$ and $x_2$ equal to 20 and 10, respectively 

$$U(x) = 100x_1^{1/3}x_2^{2/3}$$

$$e(x) = 20x_1 + 10x_2$$

What made the computational approach to expenditure minimization tricky is the fact that the constraint is the value of the *nonlinear* utility function, while the objective is the *linear* expenditure function. The code we used to solve the problem was: 

```{r xTilde, echo = TRUE}
library(Rsolnp)
A = 100
alpha = 1/3
p1 = 10
p2 = 20
ux <- function(x) {
  A * x[1] ^ (alpha) * x[2] ^ (1 - alpha)
}
bc <- function(x) {
  p1*x[1] + p2*x[2]
}
xTilde <- solnp(
  pars = c(1,1),
  fun = bc,
  ineqfun = ux,
  ineqLB = 2500,
  ineqUB = Inf,
  LB = c(0, 0),
  UB = c(Inf, Inf), 
  control = list(delta = 1e-5)
)
```

### Cost Minimization 

Find the cost-minimizing level of labor and capital at a wage of 1 and rental price of capital of 2 for a firm using a Cobb-Douglass production technology with a labor share of one-third that expects to sell 2500 units.  

```{r costMin, exercise = TRUE}


```

```{r costMin-solution}
A = 100
alpha = 1/3
p1 = 10
p2 = 20
ux <- function(x) {
  A * x[1] ^ (alpha) * x[2] ^ (1 - alpha)
}
bc <- function(x) {
  p1*x[1] + p2*x[2]
}
costmin <- solnp(
  pars = c(1,1),
  fun = bc,
  ineqfun = ux,
  ineqLB = 2500,
  ineqUB = Inf,
  LB = c(0, 0),
  UB = c(Inf, Inf), 
  control = list(delta = 1e-5)
)
```

```{r costMin-check}
grade_this({if (!inherits(.result, c("list"))) {
    fail("Your class of your answer should be a list")}
  if (.result$pars != c(25, 25)) { 
    fail("The values of L and K should equal (25, 25).") }
  pass()
})
```

## Summary

1. A firm seeks to produce any given quantity with a combination of inputs that minimizes its costs. 
2. The combination of inputs that minimizes per-unit costs *for a given quantity of output* represents a point on the long-run average cost curve. 
3. Choosing (or anticipating) the right *quantity* of output consumers will buy at a given price determines whether the firm will maximize its profits. 

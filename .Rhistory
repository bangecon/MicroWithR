xlab = "Quantity",
ylab = "Total Cost"
)
lines(
srCrtsSchedule$Quantity,
srCrtsSchedule$Variable_Cost,
col = 'purple'
)
plot(
srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Cost,
type = 'l',
ylim = c(0, 0.5),
xlab = "Quantity",
ylab = "Average Cost"
)
lines(
srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Variable_Cost,
col = 'purple'
)
srCrtsSchedule <-
data.frame(
Quantity = seq(from = 0, to = 5000, by = 100),
Labor = NA,
Capital = 25,
Total_Cost = NA,
Average_Cost = NA
)
srCrts <- function(x) {
100 * x ^ (alpha) * 25 ^ (1 - alpha)
}
srtc <- function(x) {
w * x + r * 25
}
for (i in 1:nrow(srCrtsSchedule)) {
costMinTemp <- solnp(
pars = 1,
fun = srtc,
ineqfun = srCrts,
ineqLB = srCrtsSchedule$Quantity[i],
ineqUB = Inf,
LB = 0,
UB = Inf,
control = list(trace = 0)
)
srCrtsSchedule$Labor[i] <- costMinTemp$pars[1]
srCrtsSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)
}
srCrtsSchedule$Average_Cost <-
srCrtsSchedule$Total_Cost / srCrtsSchedule$Quantity
par(mfrow = c(1, 2))
plot(
srCrtsSchedule$Quantity,
srCrtsSchedule$Total_Cost,
type = 'l',
ylim = c(0, 2500),
xlab = "Quantity",
ylab = "Total Cost"
)
plot(
srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Cost,
type = 'l',
ylim = c(0, 0.5),
xlab = "Quantity",
ylab = "Average Total Cost"
)
head(srCrtsSchedule)
srCrtsSchedule$Variable_Cost <- w * srCrtsSchedule$Labor
srCrtsSchedule$Average_Variable_Cost <-
srCrtsSchedule$Variable_Cost / srCrtsSchedule$Quantity
plot(
srCrtsSchedule$Quantity,
srCrtsSchedule$Total_Cost,
type = 'l',
ylim = c(0, 2500),
xlab = "Quantity",
ylab = "Total Cost"
)
lines(
srCrtsSchedule$Quantity,
srCrtsSchedule$Variable_Cost,
col = 'purple'
)
plot(
srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Cost,
type = 'l',
ylim = c(0, 0.5),
xlab = "Quantity",
ylab = "Average Cost"
)
lines(
srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Variable_Cost,
col = 'purple'
)
par(mfrow = c(1, 1))
# Find TC(Q_{i+1}) - TC(Q_{i-1}) / (2 * dQ)
srCrtsSchedule$Marginal_Cost <-
c(NA,diff(srCrtsSchedule$Total_Cost, lag = 2)/200, NA)
plot(
srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Cost,
type = 'l',
ylim = c(0, 0.5),
xlab = "Quantity",
ylab = "Average/Marginal Cost"
)
lines(srCrtsSchedule$Quantity,
srCrtsSchedule$Average_Variable_Cost,
col = 'purple')
lines(srCrtsSchedule$Quantity,
srCrtsSchedule$Marginal_Cost,
col = 'red')
library(learnr)
library(gradethis)
gradethis_setup(exercise.reveal_solution = FALSE, exercise.eval = TRUE)
knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)
library(Ryacas)
library(Deriv)
library(Rsolnp)
w = 1; r = 2
costSchedule <-
data.frame(
Quantity = seq(from = 0, to = 5000, by = 100),
Labor = NA,
Capital = NA,
Total_Cost = NA,
Average_Cost = NA
)
for (i in 1:nrow(costSchedule)) {
costMinTemp <- solnp(
pars = c(1, 1),
fun = function(x) w*x[1] + r*x[2],
ineqfun = function(x) 100*(x[1] + x[2]),
ineqLB = costSchedule$Quantity[i],
ineqUB = Inf,
LB = c(0, 0))
costSchedule$Labor[i] <- costMinTemp$pars[1]
costSchedule$Capital[i] <- costMinTemp$pars[2]
costSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)
}
costSchedule$Average_Cost <- costSchedule$Total_Cost / costSchedule$Quantity
par(mfrow = c(1, 2))
plot(costSchedule$Quantity, costSchedule$Total_Cost, type = 'l', ylim = c(0,50), xlab = "Quantity", ylab = "Total Cost")
plot(costSchedule$Quantity, costSchedule$Average_Cost, type = 'l', ylim = c(0,0.02), xlab = "Quantity", ylab = "Average Cost")
SRcostSchedule <-
data.frame(
Quantity = seq(from = 0, to = 5000, by = 20),
Labor = NA,
Capital = 10,
Total_Cost = NA,
Average_Cost = NA
)
for (i in 1:nrow(SRcostSchedule)) {
costMinTemp <- solnp(
pars = 1,
fun = function(x) w*x + r*10,
ineqfun = function(x) 100*(x + 10),
ineqLB = SRcostSchedule$Quantity[i],
ineqUB = Inf,
LB = 0)
SRcostSchedule$Labor[i] <- costMinTemp$pars[1]
SRcostSchedule$Variable_Cost[i] <- w*SRcostSchedule$Labor[i]
SRcostSchedule$Total_Cost[i] <- tail(costMinTemp$values, 1)
}
SRcostSchedule$Average_Cost <- SRcostSchedule$Total_Cost / SRcostSchedule$Quantity
SRcostSchedule$Average_Variable_Cost <-
SRcostSchedule$Variable_Cost / SRcostSchedule$Quantity
SRcostSchedule$Marginal_Cost <-
c(NA,diff(SRcostSchedule$Total_Cost, lag = 2)/40, NA)
par(mfrow = c(1, 2))
plot(SRcostSchedule$Quantity, SRcostSchedule$Total_Cost, type = 'l', ylim = c(0,50), xlab = "Quantity", ylab = "Total Cost")
lines(SRcostSchedule$Quantity, SRcostSchedule$Variable_Cost, col = 'darkorange')
plot(SRcostSchedule$Quantity, SRcostSchedule$Average_Cost, type = 'l', ylim = c(0,0.05), xlab = "Quantity", ylab = "Average Cost")
lines(SRcostSchedule$Quantity, SRcostSchedule$Average_Variable_Cost, col = 'darkorange')
lines(SRcostSchedule$Quantity, SRcostSchedule$Marginal_Cost, col = 'red')
MicroWithR::runTutorial(2,2)
MicroWithR::runTutorial(2,1)
MicroWithR::runTutorial(1,1)
MicroWithR::runTutorial(1,2)
MicroWithR::runTutorial(1,3)
MicroWithR::runTutorial(1,4)
MicroWithR::runTutorial(1,4)
MicroWithR::runTutorial(1,5)
MicroWithR::runTutorial(1,6)
MicroWithR::runTutorial(2,4,TRUE)
MicroWithR::runTutorial(2,3,TRUE)
MicroWithR::runTutorial(2,3,TRUE)
MicroWithR::runTutorial(2,4,TRUE)
MicroWithR::runTutorial(0,1,TRUE)
MicroWithR::runTutorial(0,1)
install.packages("survey")
# loading the api data set
data(api, package = "survey")
View(api)
tbl_summary(trial2, by = trt)
gtsummary::tbl_summary(trial2, by = trt)
library(gtsummary)
summary(trial)
trial2 <- trial %>% select(trt, age, grade)
gtsummary::tbl_summary(trial2, by = trt)
gtsummary::tbl_summary(trial2, by = trt, include = -cols_align)
gtsummary::tbl_summary(trial2, by = trt, include = -age)
gtsummary::tbl_summary(trial, by = trt)
gtsummary::tbl_summary(trial, by = trt, missing = FALSE)
gtsummary::tbl_summary(trial, by = trt, missing = "no")
gtsummary::tbl_summary(trial, by = trt, missing = "no", include = c(age, marker, grade))
gtsummary::tbl_summary(trial, by = trt, missing = "no", include = -c(age, marker, grade))
library(nleqslv)
market <- function(x) {
demand <- 6000 - 100*x[1] - x[2]
supply <- 200*x[1] - x[2]
return(c(demand, supply))
}
equilibrium <- nleqslv(c(1,1), market)
equilibrium
library(nleqslv)
market <- function(x) {
demand <- 6000 - 1000*x[1] - x[2]
supply <- 2000*x[1] - x[2]
return(c(demand, supply))
}
equilibrium <- nleqslv(c(1,1), market)
equilibrium
curve(x ^ 2 - 8 * x + 30 + 5, from = 0, to = 10)
curve(x ^ 2 - 8 * x + 30 + 5, from = 0, to = 10, ylim = c(0,60))
curve(x ^ 3 - 8 * x^2 + 30*x + 5, from = 0, to = 10, ylim = c(0,60))
curve(x ^ 3 - 8 * x^2 + 30*x + 5, from = 0, to = 10, ylim = c(0,600))
curve(x ^ 3 - 8 * x^2 + 30*x + 5, from = 0, to = 10, ylim = c(0,500))
curve(2*x, add = TRUE)
library(Rsolnp)
loss <- function(x) {
- 2*x + (x^3 - 8*x^2 +30*x + 5) # Express as a loss function to match min
}
solution <- rsolnp(par = 1, fun = loss, LB = 0)
library(Rsolnp)
loss <- function(x) {
- 2*x + (x^3 - 8*x^2 +30*x + 5) # Express as a loss function to match min
}
solution <- solnp(par = 1, fun = loss, LB = 0)
solution
mc <- function(x) 3 * x ^ 2 - 16 * x + 30
atc <- function(x) x ^ 2 - 8 * x + 30 + 5 / x
avc <- function(x) x ^ 2 - 8 * x + 30
curve(mc, from = 0, to = 8, ylim = c(0, 40), col = 'red' )
curve(atc, add = TRUE, col = 'brown')
curve(avc, add = TRUE, col = 'brown', lty = 'dashed')
curve(2, add = TRUE)
curve(2*x^0, add = TRUE)
Ryacas::deriv(ysym('Q^3 - 8*Q^2 + 30*Q + 5'), 'Q')
Ryacas::Deriv(ysym('Q^3 - 8*Q^2 + 30*Q + 5'), 'Q')
library(Ryacas)
deriv(ysym('Q^3 - 8*Q^2 + 30*Q + 5'), 'Q')
mc <- function(x) 3 * x ^ 2 - 16 * x + 30
atc <- function(x) x ^ 2 - 8 * x + 30 + 5 / x
avc <- function(x) x ^ 2 - 8 * x + 30
curve(mc, from = 0, to = 8, ylim = c(0, 40), col = 'red' )
curve(atc, add = TRUE, col = 'brown')
curve(avc, add = TRUE, col = 'brown', lty = 'dashed')
curve(20, add = TRUE)
mc <- function(x) 3 * x ^ 2 - 16 * x + 30
atc <- function(x) x ^ 2 - 8 * x + 30 + 5 / x
avc <- function(x) x ^ 2 - 8 * x + 30
curve(mc, from = 0, to = 8, ylim = c(0, 40), col = 'red' )
curve(atc, add = TRUE, col = 'brown')
curve(avc, add = TRUE, col = 'brown', lty = 'dashed')
curve(20*x^0, add = TRUE)
lines(x = c(0, 8), y = c(20, 20), col = 'blue')
fun <- function(x) {100*x[1]^(1/3)*x[2]^(2/3)}
fun2 <- -fun
fun2 <- -1*fun
fun
negate(fun)
fun
expression(fun)
as.expression(fun)
eval(fun)
eval(-1*fun)
-eval(fun)
-1*eval(fun)
fun2 <- function(x) {
-1*fun(x)
}
fun2
fun
-fun(x)
-fun(3)
-fun(c(3,3))
fun2
fun2(c(3,3))
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solnp2(c(1,1), fun = fun2, ineqfun = 10*x[1] + 20*x[2], ineqLB = c(-Inf, -Inf), ineqUB = 100, LB = c(0,0))
solnp(c(1,1), fun = fun2, ineqfun = 10*x[1] + 20*x[2], ineqLB = c(-Inf, -Inf), ineqUB = 100, LB = c(0,0))
solnp(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = c(-Inf, -Inf), ineqUB = 100, LB = c(0,0))
solnp(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
install.packages("matrixcalc")
solution <- solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
matrixcalc::is.positive.definite(solution$hessian)
solution <- solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.positive.definite(solution$hessian)
solution <- solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
matrixcalc::is.positive.definite(solution$hessian)
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.positive.definite(solution$hessian)
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.positive.definite(-solution$hessian)
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.negative.definite(-solution$hessian)
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.negative.definite(-solution$hessian)
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.negative.definite(-solution$hessian)
solution
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.negative.definite(solution$hessian)
solnp
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.negative.definite(solution$hessian)
solution
solution <- solnp(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
matrixcalc::is.negative.definite(solution$hessian)
solution
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
matrixcalc::is.negative.definite(solution$hessian)
solution
solution <- solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
solution$hessian
solution <- solnp(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
solution$hessian
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
source("D:/Google Drive/Teaching/IntermediateMicro/MicroWithR/MicroWithR/R/solnp2.R", echo=TRUE)
solution <- solnp(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
solution$hessian
solution <- solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
solution$hessian
solution$lagrange
solution$values
solution$pars
solution <- solnp2(c(1,1), fun = fun, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'max')
solution$hessian
fun2
det(solution$hessian)
solution <- solnp(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0))
det(solution$hessian)
solution$lagrange
solution <- solnp2(c(1,1), fun = fun2, ineqfun = function(x) 10*x[1] + 20*x[2], ineqLB = -Inf, ineqUB = 100, LB = c(0,0), type = 'min')
solution$lagrange
MicroWithR::runTutorial(2,4,TRUE)
curve(x^2/20 - 0.9*x + 10 + 5/x)
curve(x^2/20 - 0.9*x + 10 + 5/x, from = 0, to = 2000)
curve(x^2/20 - 0.9*x + 10, add = T, col = 'brown')
curve(x^2/20 - 0.9*x + 10 + 5/x, from = 0, to = 20)
curve(x^2/20 - 0.9*x + 10 + 5/x, from = 0, to = 20, ylim = c(0,15))
curve(x^2/20 - 9*x/10 + 10 + 5/x, from = 0, to = 20, ylim = c(0,15))
curve(x^2/20 - 9*x/10 + 10 + 5/x, from = 0, to = 20, ylim = c(0,1000))
curve(x^2/20 - 9*x/10 + 10 + 5/x, from = 0, to = 20, ylim = c(0,15))
curve(3*x^2/20 - 9*x/5 + 10, add = T, col = 'red')
curve(x^2/20 - 9*x/10 + 10, add = T, col = 'darkblue')
MicroWithR::runTutorial(2,5)
MicroWithR::runTutorial(3,1)
library(Rsolnp); a = 0.25; p2 = 1; m = 100
ux <- function(x) - x[1] ^ a * x[2] ^ (1 - a)
p1 <- seq(0.25, 2.5, 0.05)
bc <- function(x) p1[i]*x[1] + p2*x[2] # p1 is now a vector
c1 <- NULL
for (i in 1:length(p1)) {
if(i == 1) {
pars <- c(1,1)
} else {
pars <- c
}
c <- solnp(
pars = pars,
ux,
ineqfun = bc,
ineqLB = 0,
ineqUB = m,
LB = c(0, 0),
UB = c(Inf, Inf),
control = list(trace = 0)
)$pars
c1[i] <- c[1]
}
plot(c1,
p1,
type = 'l',
xlim = c(0, 50),
ylim = c(0, 2.5),
xlab = 'Quantity of Good 1',
ylab = 'Price of Good 1')
library(MicroWithR)
library(Rsolnp); a = 0.25; p2 = 1; m = 100; p1 <- seq(0.25, 2.5, 0.05)
ux <- function(x) - x[1] ^ a * x[2] ^ (1 - a)
bc <- function(x) p1[i]*x[1] + p2*x[2]
c1 <- NULL
for (i in 1:length(p1)) {
if(i == 1) {pars <- c(1,1) }
else {pars <- c1[i-1]}
c1[i] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars[1]
}
pars
i
library(Rsolnp); a = 0.25; p2 = 1; m = 100; p1 <- seq(0.25, 2.5, 0.05)
ux <- function(x) - x[1] ^ a * x[2] ^ (1 - a)
bc <- function(x) p1[i]*x[1] + p2*x[2]
c1 <- NULL
for (i in 1:length(p1)) {
if(i == 1) {pars <- c(1,1) }
else {pars <- c1[i-1]}
c1[i] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
}
i
pars
i = 1
library(Rsolnp); a = 0.25; p2 = 1; m = 100; p1 <- seq(0.25, 2.5, 0.05)
ux <- function(x) - x[1] ^ a * x[2] ^ (1 - a)
bc <- function(x) p1[i]*x[1] + p2*x[2]
c1 <- NULL
for (i in 1:length(p1)) {
if(i == 1) {pars <- c(1,1) }
else {pars <- c1[i-1]}
c1[i] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
}
pars
c1
library(Rsolnp); a = 0.25; p2 = 1; m = 100; p1 <- seq(0.25, 2.5, 0.05)
ux <- function(x) - x[1] ^ a * x[2] ^ (1 - a)
bc <- function(x) p1[i]*x[1] + p2*x[2]
c1 <- NULL
c1[1] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
c1[[1]] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
pars
i
pars <- c(1,1)
c1[[1]] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
c1
pars <- c1[[1]]
c1[[2]] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
c1
i
i = 1
pars <- c(1,1)
c1[[i]] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
c1
i = 2
pars <- c1[[i-1]]
c1[[i]] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
c1
i = 3
pars <- c1[[i-1]]
c1[[i]] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
c1
library(Rsolnp); a = 0.25; p2 = 1; m = 100; p1 <- seq(0.25, 2.5, 0.05)
ux <- function(x) - x[1] ^ a * x[2] ^ (1 - a)
bc <- function(x) p1[i]*x[1] + p2*x[2]
c1 <- NULL
for (i in 1:length(p1)) {
if(i == 1) {pars <- c(1,1) }
else {pars <- c1[i-1]}
c1[i] <- solnp(pars = pars, ux, ineqfun = bc, ineqLB = 0, ineqUB = m, LB = c(0, 0),
UB = c(Inf, Inf), control = list(trace = 0))$pars
}
library(AER)
data("CigarettesSW", package = "AER")
CigarettesSW <- transform(CigarettesSW,
rprice  = price/cpi,
rincome = income/population/cpi,
tdiff   = (taxs - tax)/cpi
)
## model
fm <- ivreg(log(packs) ~ log(rprice) + log(rincome) | log(rincome) + tdiff + I(tax/cpi),
data = CigarettesSW, subset = year == "1995")
summary(fm)
summary(fm, diagnostics = T)
data("CigarettesSW", package = "AER")
CigarettesSW <- transform(CigarettesSW,
rprice  = price/cpi,
rincome = income/population/cpi,
tdiff   = (taxs - tax)/cpi
)
## model
fm <- ivreg(log(packs) ~ log(rprice) + log(rincome) | log(rincome) + tdiff + I(tax/cpi),
data = CigarettesSW, subset = year == "1995")
summary(fm)
summary(fm, diagnostics = T)
class(fm)
?summary.ivreg
54^(1/3)*54^(2/3)
54000**2
54**2

tc <- function(x) {
w * x[1] + r * x[2]                     # Define objective
}
output <- function(x) {
x[1]^(a/0.1*i) * x[2]^((1-a)/0.1*i)     # Define constraint
}
for (i in 1:nrow(costs)) {                # Initialize for-loop
if(i==1){
pars = c(1,1)
} else{
pars = costs[i, c('L','K')]           # Set initial pars
}
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = output,
ineqLB = i,                           # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
costs$L[i] <- temp$pars[1]              # Optimal labor input
costs$K[i] <- temp$pars[2]              # Optimal capital input
costs$TC[i] <- tc(temp$values)          # Calculate total cost
}
i
i
for (i in 1:nrow(costs)) {                # Initialize for-loop
if(i==1){
pars = c(1,1)
} else{
pars = costs[i, c('L','K')]           # Set initial pars
}
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = output,
ineqLB = coss$Q[i],                   # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
costs$L[i] <- temp$pars[1]              # Optimal labor input
costs$K[i] <- temp$pars[2]              # Optimal capital input
costs$TC[i] <- tc(temp$values)          # Calculate total cost
}
for (i in 1:nrow(costs)) {                # Initialize for-loop
if(i==1){
pars = c(1,1)
} else{
pars = costs[i, c('L','K')]           # Set initial pars
}
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = output,
ineqLB = costs$Q[i],                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
costs$L[i] <- temp$pars[1]              # Optimal labor input
costs$K[i] <- temp$pars[2]              # Optimal capital input
costs$TC[i] <- tc(temp$values)          # Calculate total cost
}
i
temp
0.5/(0.1)
0.5/(0.1*2)
0.5/(0.1*3)
0.5/(0.1*9)
0.5/(0.1*10)
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = output,
ineqLB = 2,                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
output
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = function(x) x[1]^(a/0.2) * x[2]^((1-a)/0.2),
ineqLB = 2,                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = function(x) x[1]^(0.5/0.2) * x[2]^((1-0.5)/0.2),
ineqLB = 2,                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
tc
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = function(x) x[1]^(0.5) * x[2]^((1-0.5)),
ineqLB = 2,                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = function(x) x[1]^(0.5) * x[2]^((1-0.5)),
ineqLB = 2,
ineqUB = Inf,
LB = c(0, 0),
UB = c(Inf, Inf),
control = list(trace = 0)
)
pars
head(costs)
w = 10
r = 10
a = 0.5
costs <-
data.frame(
Q = seq(1, 50, 1),                    # Initialize 51 Q's
L = NA,
K = NA,
TC = NA,
ATC = NA
)
tc <- function(x) {
w * x[1] + r * x[2]                     # Define objective
}
output <- function(x) {
x[1]^(a/0.1*i) * x[2]^((1-a)/0.1*i)     # Define constraint
}
for (i in 1:nrow(costs)) {                # Initialize for-loop
if(i==1){
pars = c(1,1)
} else{
pars = costs[i-1, c('L','K')]           # Set initial pars
}
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = output,
ineqLB = costs$Q[i],                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
costs$L[i] <- temp$pars[1]              # Optimal labor input
costs$K[i] <- temp$pars[2]              # Optimal capital input
costs$TC[i] <- tc(temp$values)          # Calculate total cost
}
i
hea(costs)
head(costs)
temp
tc(c(1,1))
w = 10
r = 10
a = 0.5
costs <-
data.frame(
Q = seq(1, 50, 1),                    # Initialize 51 Q's
L = NA,
K = NA,
TC = NA,
ATC = NA
)
tc <- function(x) {
w * x[1] + r * x[2]                     # Define objective
}
output <- function(x) {
x[1]^(a/0.1*i) * x[2]^((1-a)/0.1*i)     # Define constraint
}
for (i in 1:nrow(costs)) {                # Initialize for-loop
if(i==1){
pars = c(1,1)
} else{
pars = costs[i-1, c('L','K')]           # Set initial pars
}
temp <- solnp(
pars = pars,
fun = tc,
ineqfun = output,
ineqLB = costs$Q[i],                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
costs$L[i] <- temp$pars[1]              # Optimal labor input
costs$K[i] <- temp$pars[2]              # Optimal capital input
costs$TC[i] <- tc(temp$pars)          # Calculate total cost
}
head(costs)
pars
c(pars)
for (i in 1:nrow(costs)) {                # Initialize for-loop
if(i==1){
pars = c(1,1)
} else{
pars = costs[i-1, c('L','K')]           # Set initial pars
}
temp <- solnp(
pars = c(1,1),
fun = tc,
ineqfun = output,
ineqLB = costs$Q[i],                  # Set ineqLB to Q[i]
ineqUB = Inf,
LB = c(0, 0),                         # Nonnegative constraint
UB = c(Inf, Inf),
control = list(trace = 0)
)
costs$L[i] <- temp$pars[1]              # Optimal labor input
costs$K[i] <- temp$pars[2]              # Optimal capital input
costs$TC[i] <- tc(temp$pars)          # Calculate total cost
}
i
costs
# Chunk 1: setup
library(learnr)
library(gradethis)
gradethis_setup(exercise.reveal_solution = TRUE, exercise.eval = TRUE)
knitr::opts_chunk$set(echo = FALSE, fig.height = 6, fig.width = 6)
# Chunk 2
curve(3 - x/2000000, from = 0, to = 6000000, col = 'blue')
curve(3 - x/1000000, add = TRUE, col = 'blue', lty = 'dashed')
# Chunk 3: mr
library(Ryacas)
tr.ysym <- ysym('3*x - x^2/2000000')
mr.ysym <- deriv(tr.ysym, 'x')
# Chunk 4
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue')
curve(3 - x/1e6, add = TRUE, col = 'blue')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve((x^2)/2916e11, add = TRUE, col = 'pink3')
legend(
'topright',
legend = c('Demand', 'MR', expression(SRATC[1]),
expression(AVC[1]), expression(MC[1])),
lty = 1, col = c('darkblue', 'blue', 'firebrick', 'pink3', 'red'))
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue')
curve(3 - x/1e6, add = TRUE, col = 'blue')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve((x^2)/2916e11, add = TRUE, col = 'pink2')
legend(
'topright',
legend = c('Demand', 'MR', 'SRATC', 'AVC', 'MC'),
lty = 1, col = c('darkblue', 'blue', 'firebrick', 'pink2', 'red'))
library(Rsolnp)
w = 10
r = 20
output <- function(x) {
100*x[1]^(1/3) * x[2]^(2/3)
}
d.Inv <- function(x) {
3 - output(x)/2000000
}
revenue <- function(x) {
output(x) * d.Inv(x)
}
profit <- function(x) {
revenue(x) - w*x[1] - r*x[2]
}
eq0 <- solnp(
par = c(1,1),
fun = function(x) -1*profit(x),
eqfun = function(x) x[2],
eqB = 54000,
LB = c(0,0)
)
eq0$pars
output(eq0$pars)
d.Inv(eq0$pars)
profit(eq0$pars)
library(Rsolnp)
w = 10
r = 20
output <- function(x) {
100*x[1]^(1/3) * x[2]^(2/3)
}
d.Inv <- function(x) {
3 - output(x)/2000000
}
revenue <- function(x) {
output(x) * d.Inv(x)
}
profit <- function(x) {
revenue(x) - w*x[1] - r*x[2]
}
eq0 <- solnp(
par = c(1,1),
fun = function(x) -1*profit(x),
eqfun = function(x) x[2],
eqB = 54000,
LB = c(0,0),
control = list(trace = 0)
)
eq0$pars
output(eq0$pars)
d.Inv(eq0$pars)
profit(eq0$pars)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'P', ylab = 'Q')
curve(3 - x/1e6, add = TRUE, col = 'blue')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve((x^2)/2916e11, add = TRUE, col = 'pink2')
legend(
'topright',
legend = c('Demand', 'MR', 'SRATC', 'AVC', 'MC'),
lty = 1, col = c('darkblue', 'blue', 'firebrick', 'pink2', 'red'))
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve(3 - x/1e6, add = TRUE, col = 'blue')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve((x^2)/2916e11, add = TRUE, col = 'pink2')
legend(
'topright',
legend = c('Demand', 'MR', 'SRATC', 'AVC', 'MC'),
lty = 1, col = c('darkblue', 'blue', 'firebrick', 'pink2', 'red'))
8474.035/54000.000
(8474.035/54000.000)^-1
3 - 2912679/1e6
summary(curve((3*x^2)/2916e11, add = TRUE, col = 'red'))
summary(curve((3*x^2)/2916e11, add = TRUE, col = 'red')$x)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(curve((3*x^2)/2916e11, add = TRUE, col = 'red')$x,
curve((3*x^2)/2916e11, add = TRUE, col = 'red')$y,
col = 'pink2')
summary(curve((3*x^2)/2916e11, add = TRUE, col = 'red')$x)
curve((3*x^2)/2916e11, add = TRUE, col = 'red')$x
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(curve((3*x^2)/2916e11, from = 0, to = 5.4e6)$x,
curve((3*x^2)/2916e11, from = 0, to = 5.4e6)$y,
col = 'pink2')
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(curve((3*x^2)/2916e11, from = 0, to = 5.4e6)$x,
curve((3*x^2)/2916e11, from = 0, to = 5.4e6)$y,
col = 'pink2', add = T)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(x = c(seq(0, 5.4e6, 100), 0), y = 3*x^2/2916e11, col = 'pink2')
q = c(seq(0, 5.4e6, 100), 0)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(x = q, y = 3*q^2/2916e11, col = 'pink2')
length(q)
q = c(seq(0, 5.4e6, 100), 0)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve((x^2)/2916e11 + 108e4/x, add = TRUE, col = 'firebrick')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(x = q, y = c(3*q[1:54001]^2/2916e11,0.3), col = 'pink2')
cs <- 0.5*(3 - 0.3)*5.4e6
cs
detach(Ryacas)
detach("package:Ryacas", unload = TRUE)
ps <- integrate(0.3 - (3*x^2)/2916e11, lower = 0, upper = 5.4e6)
ps <- integrate(function(x) 0.3 - (3*x^2)/2916e11, lower = 0, upper = 5.4e6)
ps
ps <- integrate(function(x) 0.3 - (3*x^2)/2916e11, lower = 0, upper = 5.4e6)[1]
ps
cs + ps
cs
class(ps)
ps <- integrate(function(x) 0.3 - (3*x^2)/2916e11, lower = 0, upper = 5.4e6) |>
unlist()
ps
ps <- integrate(function(x) 0.3 - (3*x^2)/2916e11, lower = 0, upper = 5.4e6)[1] |>
unlist()
ps
cs+ps
library(Rsolnp)
w = 10
r = 20
output <- function(x) {
100*x[1]^(1/3) * x[2]^(2/3)
}
d.Inv <- function(x) {
3 - output(x)/2000000
}
revenue <- function(x) {
output(x) * d.Inv(x)
}
profit <- function(x) {
revenue(x) - w*x[1] - r*x[2]
}
eq0 <- solnp(
par = c(1,1),
fun = function(x) -1*profit(x),
eqfun = function(x) x[2],
eqB = 54000,
LB = c(0,0),
control = list(trace = 0)
)
eq0$pars
output(eq0$pars)
d.Inv(eq0$pars)
profit(eq0$pars)
q2 = c(seq(0, 2912650, 50), 0)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,2912679,0), y = c(3, 1.543661, 1.543661), col = 'lightblue')
polygon(x = q, y = c(3*q[1:(length(q2)-2)]^2/2916e11,1.543661, 1.543661),
col = 'pink2')
polygon(x = q2, y = c(3*q[1:(length(q2)-2)]^2/2916e11,1.543661, 1.543661),
col = 'pink2')
q2 = c(seq(0, 2912650, 50), 0)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,2912679,0), y = c(3, 1.543661, 1.543661), col = 'lightblue')
polygon(x = q2, y = c(3*q2[1:(length(q2)-2)]^2/2916e11,1.543661, 1.543661),
col = 'pink2')
par(mfrow = c(1,2))
q1 = c(seq(0, 5.4e6, 100), 0)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,5.4e6,0), y = c(3, 0.3, 0.3), col = 'lightblue')
polygon(x = q, y = c(3*q[1:54001]^2/2916e11,0.3), col = 'pink2')
legend(
'topright',
legend = c('Demand', 'SRATC', 'MC', 'P'),
lty = 1, col = c('darkblue', 'red', 'black'))
q2 = c(seq(0, 2912650, 50), 0)
curve(3 - x/2e6, from = 0, to = 6e6, col = 'darkblue', xlab = 'Q', ylab = 'P')
curve((3*x^2)/2916e11, add = TRUE, col = 'red')
curve(0.3*x^0, add = TRUE, col = 'black')
polygon(x = c(0,2912679,0), y = c(3, 1.543661, 1.543661), col = 'lightblue')
polygon(x = q2, y = c(3*q2[1:(length(q2)-2)]^2/2916e11,1.543661, 1.543661),
col = 'pink2')
legend(
'topright',
legend = c('Demand', 'SRATC', 'MC', 'P'),
lty = 1, col = c('darkblue', 'red', 'black'))
eq0
cs <- 0.5*(3 - 1.543661)*2912679
cs
cs.m <- 0.5*(3 - 1.543661)*2912679
cs.m
cs <- 0.5*(3 - 0.3)*5.4e6
cs
ps.m <- integrate(function(x) 1.543661 - (3*x^2)/2916e11,
lower = 0, upper = 5.4e6)[1] |>
unlist()
ps.m
cs.m - cs
ps.m - ps
(cs.m+ps.m) - (cs+ps)
(cs+ps)
(cs.m+ps.m)
ps.m <- integrate(function(x) 1.543661 - (3*x^2)/2916e11,
lower = 0, upper = 2912679)[1] |>
unlist()
ps.m
(cs.m+ps.m)
(cs.m+ps.m) - (cs+ps)
ps.m - ps
cs.m - cs
surplusTable <- data.frame(
Monopolist = c(cs.m, ps.m, cs.m + ps.m),
Competition = c(cs, ps, cs + ps),
Change = c(cs.m - cs, ps.m - ps, (cs.m + ps.m) - (cs + ps)),
row.names = c("Consumer Surplus", "Producer Surplus", "Total Surplus")
)
surplusTable
surplusTable <- data.frame(
Monopolist = c(cs.m, ps.m, cs.m + ps.m),
Competition = c(cs, ps, cs + ps),
Change = c(cs.m - cs, ps.m - ps, (cs.m + ps.m) - (cs + ps)),
row.names = c("Consumer Surplus", "Producer Surplus", "Total Surplus")
)
surplusTable
install.packages("languageserver")
install.packages(c("bayestestR", "car", "checkmate", "collapse", "datawizard", "dplyr", "fontawesome", "fs", "gargle", "ggformula", "ggplot2", "git2r", "googleAuthR", "gt", "hardhat", "igraph", "interp", "ITNr", "labelled", "lme4", "marginaleffects", "markdown", "MASS", "MatchIt", "Matrix", "pak", "parameters", "plm", "processx", "prodlim", "ps", "quantmod", "quantreg", "RcppArmadillo", "recipes", "renv", "rms", "RSQLite", "terra", "TH.data", "tinytex", "TMB", "torch", "TSP", "V8", "vctrs", "xfun", "xts", "zip", "zoo"))
